{"file_contents":{"src/windows_audio.py":{"content":"import os\nimport sys\nimport subprocess\nfrom typing import Optional, List, Dict\n\nclass WindowsAudioController:\n    def __init__(self):\n        self.is_windows = sys.platform == 'win32'\n        self.pycaw_available = False\n        \n        if self.is_windows:\n            try:\n                from pycaw.pycaw import AudioUtilities, ISimpleAudioVolume\n                from comtypes import CLSCTX_ALL\n                from pycaw.pycaw import IAudioEndpointVolume\n                self.pycaw_available = True\n            except ImportError:\n                print(\"[AUDIO] pycaw –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∞ Windows\")\n                print(\"[AUDIO] –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install pycaw\")\n                \n    def get_running_apps(self) -> List[Dict]:\n        if not self.is_windows or not self.pycaw_available:\n            return self._get_mock_apps()\n            \n        try:\n            from pycaw.pycaw import AudioUtilities\n            \n            sessions = AudioUtilities.GetAllSessions()\n            apps = []\n            \n            for session in sessions:\n                if session.Process:\n                    apps.append({\n                        'name': session.Process.name(),\n                        'pid': session.Process.pid,\n                        'session': session\n                    })\n                    \n            return apps\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π: {e}\")\n            return []\n            \n    def _get_mock_apps(self) -> List[Dict]:\n        return [\n            {'name': 'Yandex Music (mock)', 'pid': 0, 'volume': 1.0},\n            {'name': 'Spotify (mock)', 'pid': 0, 'volume': 1.0},\n            {'name': 'Discord (mock)', 'pid': 0, 'volume': 1.0},\n            {'name': 'Chrome (mock)', 'pid': 0, 'volume': 1.0}\n        ]\n        \n    def set_app_volume(self, app_name: str, volume: float) -> bool:\n        volume = max(0.0, min(1.0, volume))\n        \n        if not self.is_windows or not self.pycaw_available:\n            print(f\"[AUDIO] (Mock) –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –≥—Ä–æ–º–∫–æ—Å—Ç—å {app_name}: {int(volume * 100)}%\")\n            return True\n            \n        try:\n            from pycaw.pycaw import AudioUtilities\n            \n            sessions = AudioUtilities.GetAllSessions()\n            \n            for session in sessions:\n                if session.Process and app_name.lower() in session.Process.name().lower():\n                    volume_interface = session._ctl.QueryInterface(\n                        __import__('pycaw.pycaw', fromlist=['ISimpleAudioVolume']).ISimpleAudioVolume\n                    )\n                    volume_interface.SetMasterVolume(volume, None)\n                    print(f\"[AUDIO] –ì—Ä–æ–º–∫–æ—Å—Ç—å {session.Process.name()}: {int(volume * 100)}%\")\n                    return True\n                    \n            print(f\"[AUDIO] –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ '{app_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ\")\n            return False\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}\")\n            return False\n            \n    def get_app_volume(self, app_name: str) -> Optional[float]:\n        if not self.is_windows or not self.pycaw_available:\n            return 1.0\n            \n        try:\n            from pycaw.pycaw import AudioUtilities, ISimpleAudioVolume\n            \n            sessions = AudioUtilities.GetAllSessions()\n            \n            for session in sessions:\n                if session.Process and app_name.lower() in session.Process.name().lower():\n                    volume_interface = session._ctl.QueryInterface(ISimpleAudioVolume)\n                    return volume_interface.GetMasterVolume()\n                    \n            return None\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}\")\n            return None\n            \n    def mute_app(self, app_name: str) -> bool:\n        return self.set_app_volume(app_name, 0.0)\n        \n    def unmute_app(self, app_name: str, volume: float = 1.0) -> bool:\n        return self.set_app_volume(app_name, volume)\n        \n    def set_master_volume(self, volume: float) -> bool:\n        volume = max(0.0, min(1.0, volume))\n        \n        if not self.is_windows:\n            print(f\"[AUDIO] (Mock) –°–∏—Å—Ç–µ–º–Ω–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å: {int(volume * 100)}%\")\n            return True\n            \n        if not self.pycaw_available:\n            try:\n                nircmd_volume = int(volume * 65535)\n                subprocess.run(['nircmd', 'setsysvolume', str(nircmd_volume)], check=True)\n                return True\n            except:\n                pass\n                \n        try:\n            from pycaw.pycaw import AudioUtilities\n            from comtypes import CLSCTX_ALL\n            from pycaw.pycaw import IAudioEndpointVolume\n            \n            devices = AudioUtilities.GetSpeakers()\n            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)\n            volume_interface = interface.QueryInterface(IAudioEndpointVolume)\n            volume_interface.SetMasterVolumeLevelScalar(volume, None)\n            \n            print(f\"[AUDIO] –°–∏—Å—Ç–µ–º–Ω–∞—è –≥—Ä–æ–º–∫–æ—Å—Ç—å: {int(volume * 100)}%\")\n            return True\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–∏—Å—Ç–µ–º–Ω–æ–π –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}\")\n            return False\n            \n    def get_master_volume(self) -> Optional[float]:\n        if not self.is_windows or not self.pycaw_available:\n            return 1.0\n            \n        try:\n            from pycaw.pycaw import AudioUtilities\n            from comtypes import CLSCTX_ALL\n            from pycaw.pycaw import IAudioEndpointVolume\n            \n            devices = AudioUtilities.GetSpeakers()\n            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)\n            volume_interface = interface.QueryInterface(IAudioEndpointVolume)\n            \n            return volume_interface.GetMasterVolumeLevelScalar()\n            \n        except Exception as e:\n            print(f\"[AUDIO] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º–Ω–æ–π –≥—Ä–æ–º–∫–æ—Å—Ç–∏: {e}\")\n            return None\n\n    def parse_volume_command(self, command: str) -> Dict:\n        command = command.lower()\n        \n        result = {\n            'action': None,\n            'app': None,\n            'volume': None\n        }\n        \n        app_keywords = {\n            '–º—É–∑—ã–∫': ['yandex', 'spotify', '–º—É–∑—ã–∫'],\n            '—è–Ω–¥–µ–∫—Å': ['yandex'],\n            'spotify': ['spotify'],\n            '–¥–∏—Å–∫–æ—Ä–¥': ['discord'],\n            'discord': ['discord'],\n            '–±—Ä–∞—É–∑–µ—Ä': ['chrome', 'firefox', 'browser', 'edge'],\n            '—Ö—Ä–æ–º': ['chrome'],\n            'chrome': ['chrome']\n        }\n        \n        for keyword, apps in app_keywords.items():\n            if keyword in command:\n                result['app'] = apps[0]\n                break\n                \n        if '—Ç–∏—à–µ' in command or '—É–±–∞–≤' in command or '–ø–æ–Ω–∏–∑—å' in command:\n            result['action'] = 'decrease'\n            result['volume'] = 0.3\n        elif '–≥—Ä–æ–º—á–µ' in command or '–ø—Ä–∏–±–∞–≤' in command or '–ø–æ–≤—ã—Å—å' in command:\n            result['action'] = 'increase'\n            result['volume'] = 0.7\n        elif '–≤—ã–∫–ª—é—á' in command or '–∑–∞–º—É—Ç' in command or 'mute' in command:\n            result['action'] = 'mute'\n            result['volume'] = 0.0\n        elif '–≤–∫–ª—é—á' in command or '—Ä–∞–∑–º—É—Ç' in command or 'unmute' in command:\n            result['action'] = 'unmute'\n            result['volume'] = 1.0\n        elif any(word in command for word in ['50%', '–ø–æ–ª–æ–≤–∏–Ω', '—Å—Ä–µ–¥–Ω']):\n            result['action'] = 'set'\n            result['volume'] = 0.5\n        elif any(word in command for word in ['100%', '–º–∞–∫—Å–∏–º', '–ø–æ–ª–Ω']):\n            result['action'] = 'set'\n            result['volume'] = 1.0\n        elif any(word in command for word in ['25%', '—á–µ—Ç–≤–µ—Ä—Ç—å']):\n            result['action'] = 'set'\n            result['volume'] = 0.25\n            \n        return result\n        \n    def execute_voice_command(self, command: str) -> str:\n        parsed = self.parse_volume_command(command)\n        \n        if not parsed['action']:\n            return \"–ù–µ –ø–æ–Ω—è–ª –∫–æ–º–∞–Ω–¥—É. –°–∫–∞–∂–∏ –Ω–∞–ø—Ä–∏–º–µ—Ä: '—Å–¥–µ–ª–∞–π –º—É–∑—ã–∫—É —Ç–∏—à–µ' –∏–ª–∏ '–≤—ã–∫–ª—é—á–∏ –¥–∏—Å–∫–æ—Ä–¥'\"\n            \n        if parsed['app']:\n            if parsed['action'] == 'mute':\n                success = self.mute_app(parsed['app'])\n                return f\"{'–í—ã–∫–ª—é—á–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ –≤—ã–∫–ª—é—á–∏—Ç—å'} {parsed['app']}\"\n            elif parsed['action'] == 'unmute':\n                success = self.unmute_app(parsed['app'])\n                return f\"{'–í–∫–ª—é—á–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ –≤–∫–ª—é—á–∏—Ç—å'} {parsed['app']}\"\n            else:\n                success = self.set_app_volume(parsed['app'], parsed['volume'])\n                percent = int(parsed['volume'] * 100)\n                return f\"{'–£—Å—Ç–∞–Ω–æ–≤–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å'} –≥—Ä–æ–º–∫–æ—Å—Ç—å {parsed['app']} –Ω–∞ {percent}%\"\n        else:\n            if parsed['action'] == 'mute':\n                success = self.set_master_volume(0.0)\n                return \"–í—ã–∫–ª—é—á–∏–ª–∞ –∑–≤—É–∫\" if success else \"–ù–µ —Å–º–æ–≥–ª–∞ –≤—ã–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫\"\n            elif parsed['action'] == 'unmute':\n                success = self.set_master_volume(1.0)\n                return \"–í–∫–ª—é—á–∏–ª–∞ –∑–≤—É–∫\" if success else \"–ù–µ —Å–º–æ–≥–ª–∞ –≤–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫\"\n            else:\n                success = self.set_master_volume(parsed['volume'])\n                percent = int(parsed['volume'] * 100)\n                return f\"{'–£—Å—Ç–∞–Ω–æ–≤–∏–ª–∞' if success else '–ù–µ —Å–º–æ–≥–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å'} —Å–∏—Å—Ç–µ–º–Ω—É—é –≥—Ä–æ–º–∫–æ—Å—Ç—å –Ω–∞ {percent}%\"\n","path":null,"size_bytes":10209,"size_tokens":null},"src/achievements.py":{"content":"import time\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional, Callable\nfrom collections import defaultdict\n\n@dataclass\nclass Achievement:\n    id: str\n    name: str\n    description: str\n    icon: str = \"üèÜ\"\n    unlocked: bool = False\n    unlocked_at: Optional[float] = None\n    progress: int = 0\n    target: int = 1\n\n@dataclass\nclass StreamStats:\n    total_kills: int = 0\n    total_deaths: int = 0\n    total_assists: int = 0\n    rounds_won: int = 0\n    rounds_lost: int = 0\n    clutches_won: int = 0\n    aces: int = 0\n    headshots: int = 0\n    donations_received: int = 0\n    donations_total: float = 0.0\n    new_subscribers: int = 0\n    raids_received: int = 0\n    chat_messages: int = 0\n    stream_duration: float = 0.0\n    kill_streak_max: int = 0\n    death_streak_max: int = 0\n    current_kill_streak: int = 0\n    current_death_streak: int = 0\n    matches_played: int = 0\n    matches_won: int = 0\n\nclass AchievementSystem:\n    def __init__(self, achievement_callback: Optional[Callable[[Achievement], None]] = None):\n        self.achievement_callback = achievement_callback\n        self.stats = StreamStats()\n        self.session_start = time.time()\n        self.achievements: Dict[str, Achievement] = {}\n        self._init_achievements()\n        \n    def _init_achievements(self):\n        achievements_data = [\n            (\"first_blood\", \"–ü–µ—Ä–≤–∞—è –∫—Ä–æ–≤—å\", \"–ü–µ—Ä–≤–æ–µ —É–±–∏–π—Å—Ç–≤–æ –Ω–∞ —Å—Ç—Ä–∏–º–µ\", \"ü©∏\", 1),\n            (\"killing_spree\", \"–°–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤\", \"5 —É–±–∏–π—Å—Ç–≤ –ø–æ–¥—Ä—è–¥ –±–µ–∑ —Å–º–µ—Ä—Ç–∏\", \"üî•\", 5),\n            (\"unstoppable\", \"–ù–µ–æ—Å—Ç–∞–Ω–æ–≤–∏–º—ã–π\", \"10 —É–±–∏–π—Å—Ç–≤ –ø–æ–¥—Ä—è–¥ –±–µ–∑ —Å–º–µ—Ä—Ç–∏\", \"‚ö°\", 10),\n            (\"ace_master\", \"–ú–∞—Å—Ç–µ—Ä ACE\", \"–°–¥–µ–ª–∞—Ç—å ACE (5 —É–±–∏–π—Å—Ç–≤ –≤ —Ä–∞—É–Ω–¥–µ)\", \"üéØ\", 1),\n            (\"clutch_king\", \"–ö–æ—Ä–æ–ª—å –∫–ª–∞—Ç—á–µ–π\", \"–í—ã–∏–≥—Ä–∞—Ç—å 3 clutch —Å–∏—Ç—É–∞—Ü–∏–∏\", \"üëë\", 3),\n            (\"headhunter\", \"–û—Ö–æ—Ç–Ω–∏–∫ –∑–∞ –≥–æ–ª–æ–≤–∞–º–∏\", \"50 —Ö–µ–¥—à–æ—Ç–æ–≤ –∑–∞ —Å—Ç—Ä–∏–º\", \"üíÄ\", 50),\n            (\"survivor\", \"–í—ã–∂–∏–≤—à–∏–π\", \"–í—ã–∂–∏—Ç—å —Å 1 HP\", \"‚ù§Ô∏è\", 1),\n            (\"comeback_kid\", \"–ö–∞–º–±—ç–∫\", \"–í—ã–∏–≥—Ä–∞—Ç—å –º–∞—Ç—á –ø—Ä–æ–∏–≥—Ä—ã–≤–∞—è 5+ —Ä–∞—É–Ω–¥–æ–≤\", \"üîÑ\", 1),\n            (\"popular\", \"–ü–æ–ø—É–ª—è—Ä–Ω—ã–π\", \"–ü–æ–ª—É—á–∏—Ç—å 10 —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ\", \"üí¨\", 10),\n            (\"loved\", \"–õ—é–±–∏–º–µ—Ü\", \"–ü–æ–ª—É—á–∏—Ç—å 5 –¥–æ–Ω–∞—Ç–æ–≤\", \"üíù\", 5),\n            (\"whale_friend\", \"–î—Ä—É–≥ –∫–∏—Ç–æ–≤\", \"–ü–æ–ª—É—á–∏—Ç—å –¥–æ–Ω–∞—Ç 1000+ —Ä—É–±–ª–µ–π\", \"üêã\", 1),\n            (\"raided\", \"–ü–æ–¥ —Ä–µ–π–¥–æ–º\", \"–ü–æ–ª—É—á–∏—Ç—å —Ä–µ–π–¥ 50+ –∑—Ä–∏—Ç–µ–ª–µ–π\", \"üöÄ\", 1),\n            (\"marathon\", \"–ú–∞—Ä–∞—Ñ–æ–Ω–µ—Ü\", \"–°—Ç—Ä–∏–º–∏—Ç—å 4+ —á–∞—Å–∞\", \"‚è±Ô∏è\", 1),\n            (\"consistent\", \"–°—Ç–∞–±–∏–ª—å–Ω—ã–π\", \"–ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π KD –≤–µ—Å—å –º–∞—Ç—á\", \"üìà\", 1),\n            (\"team_player\", \"–ö–æ–º–∞–Ω–¥–Ω—ã–π –∏–≥—Ä–æ–∫\", \"10 –∞—Å—Å–∏—Å—Ç–æ–≤ –∑–∞ –º–∞—Ç—á\", \"ü§ù\", 10),\n            (\"economical\", \"–≠–∫–æ–Ω–æ–º–Ω—ã–π\", \"–í—ã–∏–≥—Ä–∞—Ç—å —ç–∫–æ —Ä–∞—É–Ω–¥\", \"üí∞\", 1),\n            (\"ninja\", \"–ù–∏–Ω–¥–∑—è\", \"–î–µ—Ñ—É–∑ –±–æ–º–±—ã –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–µ–∫—É–Ω–¥–µ\", \"ü•∑\", 1),\n            (\"dedication\", \"–ü—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç—å\", \"10 –º–∞—Ç—á–µ–π –∑–∞ —Å–µ—Å—Å–∏—é\", \"üéÆ\", 10),\n            (\"sub_love\", \"–õ—é–±–æ–≤—å –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤\", \"10 –Ω–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤\", \"üíú\", 10),\n            (\"perfect_round\", \"–ò–¥–µ–∞–ª—å–Ω—ã–π —Ä–∞—É–Ω–¥\", \"–í—ã–∏–≥—Ä–∞—Ç—å —Ä–∞—É–Ω–¥ –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ HP\", \"‚ú®\", 1),\n        ]\n        \n        for ach_id, name, desc, icon, target in achievements_data:\n            self.achievements[ach_id] = Achievement(\n                id=ach_id,\n                name=name,\n                description=desc,\n                icon=icon,\n                target=target\n            )\n            \n    def _unlock_achievement(self, ach_id: str):\n        if ach_id not in self.achievements:\n            return\n            \n        achievement = self.achievements[ach_id]\n        if achievement.unlocked:\n            return\n            \n        achievement.unlocked = True\n        achievement.unlocked_at = time.time()\n        achievement.progress = achievement.target\n        \n        print(f\"[ACHIEVEMENT] üèÜ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: {achievement.name} - {achievement.description}\")\n        \n        if self.achievement_callback:\n            self.achievement_callback(achievement)\n            \n    def _update_progress(self, ach_id: str, progress: int = 1):\n        if ach_id not in self.achievements:\n            return\n            \n        achievement = self.achievements[ach_id]\n        if achievement.unlocked:\n            return\n            \n        achievement.progress += progress\n        \n        if achievement.progress >= achievement.target:\n            self._unlock_achievement(ach_id)\n            \n    def record_kill(self, headshot: bool = False, round_kills: int = 1):\n        self.stats.total_kills += 1\n        self.stats.current_kill_streak += 1\n        self.stats.current_death_streak = 0\n        \n        if self.stats.current_kill_streak > self.stats.kill_streak_max:\n            self.stats.kill_streak_max = self.stats.current_kill_streak\n            \n        if headshot:\n            self.stats.headshots += 1\n            self._update_progress(\"headhunter\", 1)\n            \n        if self.stats.total_kills == 1:\n            self._unlock_achievement(\"first_blood\")\n            \n        if self.stats.current_kill_streak >= 5:\n            self._unlock_achievement(\"killing_spree\")\n            \n        if self.stats.current_kill_streak >= 10:\n            self._unlock_achievement(\"unstoppable\")\n            \n        if round_kills >= 5:\n            self.stats.aces += 1\n            self._unlock_achievement(\"ace_master\")\n            \n    def record_death(self):\n        self.stats.total_deaths += 1\n        self.stats.current_death_streak += 1\n        self.stats.current_kill_streak = 0\n        \n        if self.stats.current_death_streak > self.stats.death_streak_max:\n            self.stats.death_streak_max = self.stats.current_death_streak\n            \n    def record_assist(self):\n        self.stats.total_assists += 1\n        self._update_progress(\"team_player\", 1)\n        \n    def record_round_win(self, clutch: bool = False, eco: bool = False, perfect: bool = False):\n        self.stats.rounds_won += 1\n        \n        if clutch:\n            self.stats.clutches_won += 1\n            self._update_progress(\"clutch_king\", 1)\n            \n        if eco:\n            self._unlock_achievement(\"economical\")\n            \n        if perfect:\n            self._unlock_achievement(\"perfect_round\")\n            \n    def record_round_loss(self):\n        self.stats.rounds_lost += 1\n        \n    def record_low_health_survive(self, health: int):\n        if health <= 1:\n            self._unlock_achievement(\"survivor\")\n            \n    def record_ninja_defuse(self):\n        self._unlock_achievement(\"ninja\")\n        \n    def record_donation(self, amount: float, currency: str = \"RUB\"):\n        self.stats.donations_received += 1\n        self.stats.donations_total += amount\n        \n        self._update_progress(\"loved\", 1)\n        \n        if currency == \"RUB\" and amount >= 1000:\n            self._unlock_achievement(\"whale_friend\")\n        elif currency == \"USD\" and amount >= 15:\n            self._unlock_achievement(\"whale_friend\")\n            \n    def record_subscription(self):\n        self.stats.new_subscribers += 1\n        self._update_progress(\"sub_love\", 1)\n        \n    def record_raid(self, viewers: int):\n        self.stats.raids_received += 1\n        \n        if viewers >= 50:\n            self._unlock_achievement(\"raided\")\n            \n    def record_chat_message(self):\n        self.stats.chat_messages += 1\n        self._update_progress(\"popular\", 1)\n        \n    def record_match_end(self, won: bool, came_back: bool = False):\n        self.stats.matches_played += 1\n        \n        if won:\n            self.stats.matches_won += 1\n            \n            if came_back:\n                self._unlock_achievement(\"comeback_kid\")\n                \n            if self.stats.total_kills > self.stats.total_deaths:\n                self._unlock_achievement(\"consistent\")\n                \n        self._update_progress(\"dedication\", 1)\n        \n    def check_time_achievements(self):\n        duration_hours = (time.time() - self.session_start) / 3600\n        self.stats.stream_duration = duration_hours\n        \n        if duration_hours >= 4:\n            self._unlock_achievement(\"marathon\")\n            \n    def get_unlocked_achievements(self) -> List[Achievement]:\n        return [a for a in self.achievements.values() if a.unlocked]\n        \n    def get_locked_achievements(self) -> List[Achievement]:\n        return [a for a in self.achievements.values() if not a.unlocked]\n        \n    def get_progress_summary(self) -> str:\n        unlocked = len(self.get_unlocked_achievements())\n        total = len(self.achievements)\n        \n        return f\"–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è: {unlocked}/{total}\"\n        \n    def get_stats_summary(self) -> str:\n        s = self.stats\n        kd = s.total_kills / max(1, s.total_deaths)\n        \n        return f\"\"\"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—Ç—Ä–∏–º–∞:\nüéØ K/D/A: {s.total_kills}/{s.total_deaths}/{s.total_assists} (KD: {kd:.2f})\nüèÜ –†–∞—É–Ω–¥—ã: {s.rounds_won}W / {s.rounds_lost}L\nüî• –ú–∞–∫—Å. —Å–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤: {s.kill_streak_max}\nüíÄ –•–µ–¥—à–æ—Ç—ã: {s.headshots}\nüëë Clutch –ø–æ–±–µ–¥: {s.clutches_won}\n‚≠ê ACE: {s.aces}\nüí∞ –î–æ–Ω–∞—Ç—ã: {s.donations_received} ({s.donations_total:.0f} —Ä—É–±.)\nüíú –ü–æ–¥–ø–∏—Å—á–∏–∫–∏: {s.new_subscribers}\nüí¨ –°–æ–æ–±—â–µ–Ω–∏–π –≤ —á–∞—Ç–µ: {s.chat_messages}\n‚è±Ô∏è –í—Ä–µ–º—è —Å—Ç—Ä–∏–º–∞: {s.stream_duration:.1f} —á\"\"\"\n\n    def save_stats(self, filepath: str = \"stream_stats.json\"):\n        data = {\n            'stats': self.stats.__dict__,\n            'achievements': {\n                k: {\n                    'unlocked': v.unlocked,\n                    'unlocked_at': v.unlocked_at,\n                    'progress': v.progress\n                }\n                for k, v in self.achievements.items()\n            },\n            'session_start': self.session_start\n        }\n        \n        with open(filepath, 'w', encoding='utf-8') as f:\n            json.dump(data, f, ensure_ascii=False, indent=2)\n            \n        print(f\"[ACHIEVEMENTS] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {filepath}\")\n        \n    def load_stats(self, filepath: str = \"stream_stats.json\") -> bool:\n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                data = json.load(f)\n                \n            for key, value in data.get('stats', {}).items():\n                if hasattr(self.stats, key):\n                    setattr(self.stats, key, value)\n                    \n            for ach_id, ach_data in data.get('achievements', {}).items():\n                if ach_id in self.achievements:\n                    self.achievements[ach_id].unlocked = ach_data.get('unlocked', False)\n                    self.achievements[ach_id].unlocked_at = ach_data.get('unlocked_at')\n                    self.achievements[ach_id].progress = ach_data.get('progress', 0)\n                    \n            print(f\"[ACHIEVEMENTS] –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ {filepath}\")\n            return True\n            \n        except FileNotFoundError:\n            return False\n        except Exception as e:\n            print(f\"[ACHIEVEMENTS] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}\")\n            return False\n","path":null,"size_bytes":11655,"size_tokens":null},"src/cs2_gsi.py":{"content":"import json\nimport time\nimport threading\nfrom flask import Flask, request, jsonify\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Callable, Dict, List, Any\nfrom collections import deque\n\n@dataclass\nclass PlayerState:\n    name: str = \"\"\n    team: str = \"\"\n    health: int = 100\n    armor: int = 0\n    helmet: bool = False\n    money: int = 0\n    round_kills: int = 0\n    round_killhs: int = 0\n    equip_value: int = 0\n    kills: int = 0\n    assists: int = 0\n    deaths: int = 0\n    mvps: int = 0\n    score: int = 0\n    weapon: str = \"\"\n    \n@dataclass \nclass RoundState:\n    phase: str = \"\"\n    bomb: str = \"\"\n    win_team: str = \"\"\n    \n@dataclass\nclass MapState:\n    name: str = \"\"\n    mode: str = \"\"\n    phase: str = \"\"\n    round: int = 0\n    ct_score: int = 0\n    t_score: int = 0\n    \n@dataclass\nclass GameEvent:\n    event_type: str\n    data: Dict[str, Any]\n    timestamp: float = field(default_factory=time.time)\n\nclass CS2GameStateIntegration:\n    def __init__(self, \n                 port: int = 3000,\n                 event_callback: Optional[Callable[[GameEvent], None]] = None):\n        \n        self.port = port\n        self.event_callback = event_callback\n        \n        self.player = PlayerState()\n        self.round = RoundState()\n        self.map = MapState()\n        self.previous_state: Dict = {}\n        \n        self.events_history: deque = deque(maxlen=100)\n        self.kill_streak = 0\n        self.round_start_kills = 0\n        self.clutch_situation = False\n        self.clutch_enemies = 0\n        \n        self.app = Flask(__name__)\n        self._setup_routes()\n        \n        self.server_thread = None\n        self.is_running = False\n        \n    def _setup_routes(self):\n        @self.app.route('/', methods=['POST'])\n        def gsi_handler():\n            try:\n                data = request.get_json()\n                if data:\n                    self._process_game_state(data)\n                return jsonify({\"status\": \"ok\"})\n            except Exception as e:\n                print(f\"[CS2 GSI] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}\")\n                return jsonify({\"status\": \"error\"}), 500\n                \n        @self.app.route('/health', methods=['GET'])\n        def health_check():\n            return jsonify({\n                \"status\": \"running\",\n                \"player\": self.player.name,\n                \"map\": self.map.name,\n                \"round\": self.map.round\n            })\n            \n    def _process_game_state(self, data: Dict):\n        player_data = data.get('player', {})\n        if player_data:\n            state = player_data.get('state', {})\n            match_stats = player_data.get('match_stats', {})\n            weapons = player_data.get('weapons', {})\n            \n            old_health = self.player.health\n            old_kills = self.player.kills\n            old_deaths = self.player.deaths\n            old_round_kills = self.player.round_kills\n            \n            self.player.name = player_data.get('name', self.player.name)\n            self.player.team = player_data.get('team', self.player.team)\n            self.player.health = state.get('health', self.player.health)\n            self.player.armor = state.get('armor', self.player.armor)\n            self.player.helmet = state.get('helmet', self.player.helmet)\n            self.player.money = state.get('money', self.player.money)\n            self.player.round_kills = state.get('round_kills', self.player.round_kills)\n            self.player.round_killhs = state.get('round_killhs', self.player.round_killhs)\n            self.player.equip_value = state.get('equip_value', self.player.equip_value)\n            \n            self.player.kills = match_stats.get('kills', self.player.kills)\n            self.player.assists = match_stats.get('assists', self.player.assists)\n            self.player.deaths = match_stats.get('deaths', self.player.deaths)\n            self.player.mvps = match_stats.get('mvps', self.player.mvps)\n            self.player.score = match_stats.get('score', self.player.score)\n            \n            for weapon_key, weapon_data in weapons.items():\n                if weapon_data.get('state') == 'active':\n                    self.player.weapon = weapon_data.get('name', '')\n                    break\n                    \n            if self.player.kills > old_kills:\n                self._emit_kill_event(self.player.kills - old_kills)\n                \n            if self.player.deaths > old_deaths:\n                self._emit_death_event()\n                \n            if self.player.health < old_health and self.player.health > 0:\n                self._emit_damage_event(old_health - self.player.health)\n                \n        round_data = data.get('round', {})\n        if round_data:\n            old_phase = self.round.phase\n            old_bomb = self.round.bomb\n            \n            self.round.phase = round_data.get('phase', self.round.phase)\n            self.round.bomb = round_data.get('bomb', self.round.bomb)\n            self.round.win_team = round_data.get('win_team', self.round.win_team)\n            \n            if self.round.phase == 'freezetime' and old_phase != 'freezetime':\n                self._emit_round_start_event()\n                \n            if self.round.phase == 'over' and old_phase != 'over':\n                self._emit_round_end_event()\n                \n            if self.round.bomb == 'planted' and old_bomb != 'planted':\n                self._emit_bomb_planted_event()\n                \n            if self.round.bomb == 'defused' and old_bomb != 'defused':\n                self._emit_bomb_defused_event()\n                \n            if self.round.bomb == 'exploded' and old_bomb != 'exploded':\n                self._emit_bomb_exploded_event()\n                \n        map_data = data.get('map', {})\n        if map_data:\n            old_round = self.map.round\n            \n            self.map.name = map_data.get('name', self.map.name)\n            self.map.mode = map_data.get('mode', self.map.mode)\n            self.map.phase = map_data.get('phase', self.map.phase)\n            self.map.round = map_data.get('round', self.map.round)\n            \n            team_ct = map_data.get('team_ct', {})\n            team_t = map_data.get('team_t', {})\n            self.map.ct_score = team_ct.get('score', self.map.ct_score)\n            self.map.t_score = team_t.get('score', self.map.t_score)\n            \n            if self.map.phase == 'gameover':\n                self._emit_match_end_event()\n                \n        self.previous_state = data\n        \n    def _emit_event(self, event_type: str, data: Dict = None):\n        event = GameEvent(event_type=event_type, data=data or {})\n        self.events_history.append(event)\n        \n        if self.event_callback:\n            try:\n                self.event_callback(event)\n            except Exception as e:\n                print(f\"[CS2 GSI] –û—à–∏–±–∫–∞ callback: {e}\")\n                \n    def _emit_kill_event(self, kill_count: int):\n        self.kill_streak += kill_count\n        \n        event_data = {\n            'kills_this_action': kill_count,\n            'round_kills': self.player.round_kills,\n            'total_kills': self.player.kills,\n            'kill_streak': self.kill_streak,\n            'headshot': self.player.round_killhs > 0,\n            'weapon': self.player.weapon,\n            'clutch': self.clutch_situation,\n            'clutch_enemies': self.clutch_enemies\n        }\n        \n        if self.player.round_kills >= 5:\n            event_data['ace'] = True\n            self._emit_event('ace', event_data)\n        elif self.player.round_kills >= 4:\n            self._emit_event('quadra_kill', event_data)\n        elif self.player.round_kills >= 3:\n            self._emit_event('triple_kill', event_data)\n        elif self.player.round_kills >= 2:\n            self._emit_event('double_kill', event_data)\n        else:\n            self._emit_event('kill', event_data)\n            \n    def _emit_death_event(self):\n        self.kill_streak = 0\n        \n        event_data = {\n            'total_deaths': self.player.deaths,\n            'kd_ratio': self.player.kills / max(1, self.player.deaths),\n            'round': self.map.round\n        }\n        self._emit_event('death', event_data)\n        \n    def _emit_damage_event(self, damage: int):\n        event_data = {\n            'damage': damage,\n            'current_health': self.player.health,\n            'armor': self.player.armor\n        }\n        \n        if self.player.health <= 25:\n            self._emit_event('low_health', event_data)\n        elif damage >= 50:\n            self._emit_event('heavy_damage', event_data)\n            \n    def _emit_round_start_event(self):\n        self.kill_streak = 0\n        self.round_start_kills = self.player.kills\n        self.clutch_situation = False\n        \n        event_data = {\n            'round': self.map.round,\n            'ct_score': self.map.ct_score,\n            't_score': self.map.t_score,\n            'money': self.player.money,\n            'equip_value': self.player.equip_value\n        }\n        \n        if self.player.money < 2000:\n            event_data['eco_round'] = True\n            \n        self._emit_event('round_start', event_data)\n        \n    def _emit_round_end_event(self):\n        round_kills = self.player.kills - self.round_start_kills\n        \n        event_data = {\n            'round': self.map.round,\n            'win_team': self.round.win_team,\n            'player_team': self.player.team,\n            'won': self.round.win_team.lower() == self.player.team.lower() if self.round.win_team else False,\n            'round_kills': round_kills,\n            'clutch_win': self.clutch_situation and round_kills > 0\n        }\n        \n        if round_kills >= 3:\n            event_data['mvp_candidate'] = True\n            \n        self._emit_event('round_end', event_data)\n        \n    def _emit_bomb_planted_event(self):\n        event_data = {\n            'round': self.map.round,\n            'player_team': self.player.team\n        }\n        self._emit_event('bomb_planted', event_data)\n        \n    def _emit_bomb_defused_event(self):\n        event_data = {\n            'round': self.map.round,\n            'player_team': self.player.team,\n            'ninja_defuse': self.player.health <= 10\n        }\n        self._emit_event('bomb_defused', event_data)\n        \n    def _emit_bomb_exploded_event(self):\n        event_data = {\n            'round': self.map.round,\n            'player_team': self.player.team\n        }\n        self._emit_event('bomb_exploded', event_data)\n        \n    def _emit_match_end_event(self):\n        event_data = {\n            'ct_score': self.map.ct_score,\n            't_score': self.map.t_score,\n            'player_team': self.player.team,\n            'won': (self.player.team == 'CT' and self.map.ct_score > self.map.t_score) or\n                   (self.player.team == 'T' and self.map.t_score > self.map.ct_score),\n            'kills': self.player.kills,\n            'deaths': self.player.deaths,\n            'assists': self.player.assists,\n            'mvps': self.player.mvps,\n            'map': self.map.name\n        }\n        self._emit_event('match_end', event_data)\n        \n    def start(self):\n        if self.is_running:\n            return\n            \n        self.is_running = True\n        self.server_thread = threading.Thread(\n            target=lambda: self.app.run(host='0.0.0.0', port=self.port, debug=False, use_reloader=False),\n            daemon=True\n        )\n        self.server_thread.start()\n        print(f\"[CS2 GSI] –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {self.port}\")\n        \n    def stop(self):\n        self.is_running = False\n        \n    def get_player_stats(self) -> Dict:\n        return {\n            'name': self.player.name,\n            'team': self.player.team,\n            'health': self.player.health,\n            'armor': self.player.armor,\n            'money': self.player.money,\n            'kills': self.player.kills,\n            'deaths': self.player.deaths,\n            'assists': self.player.assists,\n            'kd_ratio': round(self.player.kills / max(1, self.player.deaths), 2),\n            'mvps': self.player.mvps,\n            'score': self.player.score\n        }\n        \n    def get_match_info(self) -> Dict:\n        return {\n            'map': self.map.name,\n            'mode': self.map.mode,\n            'round': self.map.round,\n            'ct_score': self.map.ct_score,\n            't_score': self.map.t_score,\n            'phase': self.map.phase\n        }\n        \n    def generate_config_file(self) -> str:\n        config = f'''\"Iris Stream Assistant\"\n{{\n    \"uri\" \"http://localhost:{self.port}/\"\n    \"timeout\" \"5.0\"\n    \"buffer\" \"0.1\"\n    \"throttle\" \"0.1\"\n    \"heartbeat\" \"10.0\"\n    \"auth\"\n    {{\n        \"token\" \"iris_stream_assistant\"\n    }}\n    \"data\"\n    {{\n        \"provider\"            \"1\"\n        \"map\"                 \"1\"\n        \"round\"               \"1\"\n        \"player_id\"           \"1\"\n        \"player_state\"        \"1\"\n        \"player_weapons\"      \"1\"\n        \"player_match_stats\"  \"1\"\n        \"allplayers_id\"       \"1\"\n        \"allplayers_state\"    \"1\"\n        \"bomb\"                \"1\"\n        \"phase_countdowns\"    \"1\"\n    }}\n}}'''\n        return config\n        \n    def save_config_file(self, path: str = \"gamestate_integration_iris.cfg\"):\n        config = self.generate_config_file()\n        with open(path, 'w') as f:\n            f.write(config)\n        print(f\"[CS2 GSI] –ö–æ–Ω—Ñ–∏–≥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {path}\")\n        print(f\"[CS2 GSI] –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –≤: <Steam>/steamapps/common/Counter-Strike Global Offensive/game/csgo/cfg/\")\n        return path\n","path":null,"size_bytes":13704,"size_tokens":null},"src/utils/tts_utils.py":{"content":"\"\"\"\nTTS Utils - –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º API\n\"\"\"\nfrom src.utils import synthesize_and_play\n\n__all__ = ['synthesize_and_play']\n","path":null,"size_bytes":146,"size_tokens":null},"src/__init__.py":{"content":"\nfrom .voice_recognition import VoiceRecognition, TextInputFallback\nfrom .cs2_gsi import CS2GameStateIntegration, GameEvent\nfrom .streamelements_client import StreamElementsClient, StreamEvent\nfrom .iris_brain import IrisBrain\nfrom .windows_audio import WindowsAudioController\nfrom .achievements import AchievementSystem, Achievement, StreamStats\n\n__all__ = [\n    'TTSEngine',\n    'VoiceRecognition', \n    'TextInputFallback',\n    'CS2GameStateIntegration',\n    'GameEvent',\n    'StreamElementsClient',\n    'StreamEvent',\n    'IrisBrain',\n    'WindowsAudioController',\n    'AchievementSystem',\n    'Achievement',\n    'StreamStats'\n]\n","path":null,"size_bytes":633,"size_tokens":null},"temp_repo/attached_assets/streamelements_client_1765902075685.py":{"content":"import json\r\nimport websocket\r\n\r\n# –í—Å—Ç–∞–≤—å—Ç–µ –≤–∞—à —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω —Å—é–¥–∞\r\nYOUR_JWT_TOKEN = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJjaXRhZGVsIiwiZXhwIjoxNzgxNDUzNDYwLCJqdGkiOiJjYzM3ZjUwNS1lNGRkLTQxZjktOGIwZS1lNTNhZjUzM2M0ODIiLCJjaGFubmVsIjoiNjk0MTg0OTNjMjdmNzk4NGQ1Y2UwNmNkIiwicm9sZSI6Im93bmVyIiwiYXV0aFRva2VuIjoiMVdQckRUYUZUN21mc3RHSlNfZFpxV3NtNmlicFhYeGdDbmdjcThpeHlCbG9HTXpVIiwidXNlciI6IjY5NDE4NDkzYzI3Zjc5ODRkNWNlMDZjYyIsInVzZXJfaWQiOiIwYjhiZTJhZS1kNjIyLTRlNGEtODdmMy01NjJhYTcxMGM5YWYiLCJ1c2VyX3JvbGUiOiJjcmVhdG9yIiwicHJvdmlkZXIiOiJ0d2l0Y2giLCJwcm92aWRlcl9pZCI6IjE4NzU3MjUyNyIsImNoYW5uZWxfaWQiOiJlMjU4YzczZS04ZTgxLTQyNzktOGNjMS0wZWI2OTE2ZmIyMDMiLCJjcmVhdG9yX2lkIjoiNGQ4Zjk5YzktMGE3OC00YjlkLWJlNWEtZjVmNDY2ZGMyZjk4In0.UDj-xNNlOjOplW8gliL0-cb9S8_rnuCZaQCpLUvMq1o\"\r\n\r\ndef on_message(ws, message):\r\n    \"\"\"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç StreamElements.\"\"\"\r\n    try:\r\n        data = json.loads(message)\r\n    except json.JSONDecodeError:\r\n        # –ò–Ω–æ–≥–¥–∞ –ø—Ä–∏—Ö–æ–¥—è—Ç —Å–ª—É–∂–µ–±–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –∏—Ö –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å\r\n        return\r\n\r\n    # StreamElements –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–±—ã—Ç–∏—è –≤ –ø–æ–ª–µ 'type'\r\n    event_type = data.get('type')\r\n    listener = data.get('listener')\r\n\r\n    # –°–æ–±—ã—Ç–∏–µ —á–∞—Ç–∞\r\n    if listener == 'chat-message':\r\n        event_data = data.get('data', {})\r\n        username = event_data.get('displayName', '–ê–Ω–æ–Ω–∏–º')\r\n        user_message = event_data.get('message', '')\r\n        print(f'[–ß–ê–¢] {username}: {user_message}')\r\n        # –¢—É—Ç –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –≤–∞—à –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞\r\n\r\n    # –°–æ–±—ã—Ç–∏–µ –¥–æ–Ω–∞—Ç–∞ (—Ç–∏–ø 'tip')\r\n    elif event_type == 'tip':\r\n        event_data = data.get('data', {})\r\n        donor = event_data.get('username', '–ê–Ω–æ–Ω–∏–º')\r\n        amount = event_data.get('amount', 0)\r\n        currency = event_data.get('currency', 'USD')\r\n        print(f'[–î–û–ù–ê–¢] {donor} - {amount} {currency}')\r\n        # –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –æ–∑–≤—É—á–∫–∏ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º\r\n\r\n    # –°–æ–±—ã—Ç–∏–µ –Ω–æ–≤–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ (—Ç–∏–ø 'subscriber')\r\n    elif event_type == 'subscriber':\r\n        event_data = data.get('data', {})\r\n        subscriber = event_data.get('username', '–ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫')\r\n        print(f'[–ü–û–î–ü–ò–°–ö–ê] {subscriber}')\r\n        # –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è –æ–∑–≤—É—á–∫–∏\r\n\r\ndef on_error(ws, error):\r\n    print(f\"–û—à–∏–±–∫–∞ WebSocket: {error}\")\r\n\r\ndef on_close(ws, close_status_code, close_msg):\r\n    print(\"–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å StreamElements –∑–∞–∫—Ä—ã—Ç–æ\")\r\n\r\ndef on_open(ws):\r\n    print(\"–£—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ StreamElements WebSocket!\")\r\n    # –ü–æ—Å–ª–µ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω—É–∂–Ω–æ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å—Å—è\r\n    auth_message = {\r\n        \"method\": \"jwt\",\r\n        \"token\": YOUR_JWT_TOKEN\r\n    }\r\n    ws.send(json.dumps(auth_message))\r\n\r\nif __name__ == \"__main__\":\r\n    ws_url = \"wss://realtime.streamelements.com/socket.io/?EIO=4&transport=websocket\"\r\n    ws = websocket.WebSocketApp(ws_url,\r\n                                on_open=on_open,\r\n                                on_message=on_message,\r\n                                on_error=on_error,\r\n                                on_close=on_close)\r\n    ws.run_forever()","path":null,"size_bytes":3407,"size_tokens":null},"setup.py":{"content":"# setup.py\nimport os\n\n# –°–æ–∑–¥–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Ñ–∞–π–ª—ã –∏ –ø–∞–ø–∫–∏\npaths = [\n    \"src/__init__.py\",\n    \"src/utils/__init__.py\",\n    \"src/utils/tts_utils.py\",\n    \"src/tts_engine.py\",\n    \"main.py\"\n]\n\nfor path in paths:\n    dir_name = os.path.dirname(path)\n    if dir_name and not os.path.exists(dir_name):\n        os.makedirs(dir_name, exist_ok=True)\n    \n    if not os.path.exists(path):\n        if path.endswith(\"__init__.py\"):\n            # –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç–æ–π —Ñ–∞–π–ª\n            with open(path, 'w', encoding='utf-8') as f:\n                f.write(\"# Package initializer\\n\")\n        print(f\"–°–æ–∑–¥–∞–Ω: {path}\")\n\nprint(\"–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ –≥–æ—Ç–æ–≤–∞!\")","path":null,"size_bytes":706,"size_tokens":null},"src/tts_engine.py":{"content":"\"\"\"\nIris TTS Engine - –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å —Å Edge TTS\n–ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏ —Å —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º–∏ –∏–Ω—Ç–æ–Ω–∞—Ü–∏—è–º–∏\n\"\"\"\nimport asyncio\nimport tempfile\nimport os\nimport sys\nimport threading\nimport queue\nimport time\nfrom pathlib import Path\nfrom typing import Optional, Dict, Callable\n\ntry:\n    import edge_tts\n    EDGE_TTS_AVAILABLE = True\nexcept ImportError:\n    EDGE_TTS_AVAILABLE = False\n    print(\"[TTS] edge-tts –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install edge-tts\")\n\ntry:\n    import pygame\n    PYGAME_AVAILABLE = True\nexcept ImportError:\n    PYGAME_AVAILABLE = False\n    print(\"[TTS] pygame –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install pygame\")\n\n\nclass TTSEngine:\n    \"\"\"\n    –î–≤–∏–∂–æ–∫ —Å–∏–Ω—Ç–µ–∑–∞ —Ä–µ—á–∏ —Å –Ω–µ–∂–Ω—ã–º –∂–µ–Ω—Å–∫–∏–º –≥–æ–ª–æ—Å–æ–º\n    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Edge TTS (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π, –≤—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ)\n    \"\"\"\n    \n    VOICES = {\n        'ru_female_soft': 'ru-RU-SvetlanaNeural',\n        'ru_female_warm': 'ru-RU-DariyaNeural', \n        'ru_male': 'ru-RU-DmitryNeural',\n        'en_female_soft': 'en-US-JennyNeural',\n        'en_female_warm': 'en-US-AriaNeural',\n        'en_male': 'en-US-GuyNeural',\n    }\n    \n    EMOTION_STYLES = {\n        'neutral': {'rate': '+0%', 'pitch': '+0Hz', 'volume': '+0%'},\n        'excited': {'rate': '+15%', 'pitch': '+3Hz', 'volume': '+10%'},\n        'happy': {'rate': '+10%', 'pitch': '+2Hz', 'volume': '+5%'},\n        'sad': {'rate': '-10%', 'pitch': '-2Hz', 'volume': '-5%'},\n        'supportive': {'rate': '-5%', 'pitch': '+1Hz', 'volume': '+0%'},\n        'sarcastic': {'rate': '-5%', 'pitch': '-1Hz', 'volume': '+0%'},\n        'tense': {'rate': '+20%', 'pitch': '+4Hz', 'volume': '+15%'},\n        'gentle': {'rate': '-15%', 'pitch': '+2Hz', 'volume': '-10%'},\n    }\n    \n    def __init__(self, \n                 voice: str = 'ru_female_soft',\n                 rate: int = 0,\n                 volume: float = 1.0,\n                 lang: str = 'ru'):\n        \"\"\"\n        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TTS –¥–≤–∏–∂–∫–∞\n        \n        Args:\n            voice: –ò–º—è –≥–æ–ª–æ—Å–∞ –∏–∑ VOICES –∏–ª–∏ –ø—Ä—è–º–æ–µ –∏–º—è Edge TTS\n            rate: –°–∫–æ—Ä–æ—Å—Ç—å —Ä–µ—á–∏ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (-50 –¥–æ +50)\n            volume: –ì—Ä–æ–º–∫–æ—Å—Ç—å (0.0-1.0)\n            lang: –Ø–∑—ã–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é\n        \"\"\"\n        self.voice_name = self.VOICES.get(voice, voice)\n        self.base_rate = rate\n        self.base_volume = volume\n        self.lang = lang\n        \n        self.speech_queue = queue.Queue()\n        self.is_speaking = False\n        self.stop_flag = False\n        self.current_emotion = 'neutral'\n        self.playback_available = False\n        \n        self._init_pygame()\n        \n        self.worker_thread = threading.Thread(target=self._speech_worker, daemon=True)\n        self.worker_thread.start()\n        \n        print(f\"[TTS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –≥–æ–ª–æ—Å–æ–º: {self.voice_name}\")\n        print(f\"[TTS] Edge TTS –¥–æ—Å—Ç—É–ø–µ–Ω: {EDGE_TTS_AVAILABLE}\")\n        print(f\"[TTS] –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ: {self.playback_available}\")\n    \n    def _init_pygame(self):\n        \"\"\"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è pygame mixer\"\"\"\n        if not PYGAME_AVAILABLE:\n            self.playback_available = False\n            return\n            \n        try:\n            pygame.mixer.pre_init(frequency=24000, size=-16, channels=1, buffer=512)\n            pygame.mixer.init()\n            self.playback_available = True\n            print(\"[TTS] Pygame mixer –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω\")\n        except Exception as e:\n            self.playback_available = False\n            print(f\"[TTS] –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ (–Ω–µ—Ç –∞—É–¥–∏–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤): {e}\")\n            print(\"[TTS] –°–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å, –Ω–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ\")\n    \n    def _get_rate_string(self, emotion: str = 'neutral') -> str:\n        \"\"\"–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–æ–∫—É —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–ª—è SSML\"\"\"\n        emotion_rate = self.EMOTION_STYLES.get(emotion, {}).get('rate', '+0%')\n        base = int(emotion_rate.replace('%', '').replace('+', ''))\n        total = self.base_rate + base\n        sign = '+' if total >= 0 else ''\n        return f\"{sign}{total}%\"\n    \n    def _get_pitch_string(self, emotion: str = 'neutral') -> str:\n        \"\"\"–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–æ–∫—É —Ç–æ–Ω–∞ –¥–ª—è SSML\"\"\"\n        return self.EMOTION_STYLES.get(emotion, {}).get('pitch', '+0Hz')\n    \n    def _get_volume_string(self, emotion: str = 'neutral') -> str:\n        \"\"\"–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–æ–∫—É –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –¥–ª—è SSML\"\"\"\n        return self.EMOTION_STYLES.get(emotion, {}).get('volume', '+0%')\n    \n    async def _synthesize_async(self, text: str, emotion: str = 'neutral') -> Optional[str]:\n        \"\"\"\n        –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏\n        \n        Returns:\n            str: –ü—É—Ç—å –∫ –≤—Ä–µ–º–µ–Ω–Ω–æ–º—É –∞—É–¥–∏–æ —Ñ–∞–π–ª—É\n        \"\"\"\n        if not EDGE_TTS_AVAILABLE:\n            print(\"[TTS] Edge TTS –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω\")\n            return None\n        \n        try:\n            rate = self._get_rate_string(emotion)\n            pitch = self._get_pitch_string(emotion)\n            volume = self._get_volume_string(emotion)\n            \n            communicate = edge_tts.Communicate(\n                text=text,\n                voice=self.voice_name,\n                rate=rate,\n                pitch=pitch,\n                volume=volume\n            )\n            \n            with tempfile.NamedTemporaryFile(suffix='.mp3', delete=False, prefix='iris_tts_') as tmp:\n                output_path = tmp.name\n            \n            await communicate.save(output_path)\n            \n            return output_path\n            \n        except Exception as e:\n            print(f\"[TTS] –û—à–∏–±–∫–∞ —Å–∏–Ω—Ç–µ–∑–∞: {e}\")\n            return None\n    \n    def _play_audio(self, file_path: str) -> bool:\n        \"\"\"–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞\"\"\"\n        if not self.playback_available:\n            print(f\"[TTS] –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ (–Ω–µ—Ç –∞—É–¥–∏–æ): {os.path.basename(file_path)}\")\n            return False\n        \n        if not os.path.exists(file_path):\n            print(f\"[TTS] –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {file_path}\")\n            return False\n        \n        try:\n            if not pygame.mixer.get_init():\n                self._init_pygame()\n                if not self.playback_available:\n                    return False\n            \n            pygame.mixer.music.load(file_path)\n            pygame.mixer.music.set_volume(self.base_volume)\n            pygame.mixer.music.play()\n            \n            while pygame.mixer.music.get_busy() and not self.stop_flag:\n                time.sleep(0.05)\n            \n            pygame.mixer.music.stop()\n            return True\n            \n        except Exception as e:\n            print(f\"[TTS] –û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: {e}\")\n            return False\n        finally:\n            try:\n                os.unlink(file_path)\n            except:\n                pass\n    \n    def _speech_worker(self):\n        \"\"\"–†–∞–±–æ—á–∏–π –ø–æ—Ç–æ–∫ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏ —Ä–µ—á–∏\"\"\"\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        \n        while not self.stop_flag:\n            try:\n                item = self.speech_queue.get(timeout=0.5)\n                if item is None:\n                    continue\n                \n                text, emotion, priority, callback = item\n                \n                self.is_speaking = True\n                self.current_emotion = emotion\n                \n                print(f\"[TTS] –°–∏–Ω—Ç–µ–∑–∏—Ä—É—é: '{text[:50]}...' —ç–º–æ—Ü–∏—è: {emotion}\")\n                \n                audio_file = loop.run_until_complete(\n                    self._synthesize_async(text, emotion)\n                )\n                \n                if audio_file:\n                    success = self._play_audio(audio_file)\n                    if callback:\n                        callback(success)\n                \n                self.is_speaking = False\n                self.speech_queue.task_done()\n                \n            except queue.Empty:\n                continue\n            except Exception as e:\n                print(f\"[TTS] –û—à–∏–±–∫–∞ –≤ —Ä–∞–±–æ—á–µ–º –ø–æ—Ç–æ–∫–µ: {e}\")\n                self.is_speaking = False\n        \n        loop.close()\n    \n    def speak(self, \n              text: str, \n              emotion: str = 'neutral',\n              priority: bool = False,\n              callback: Optional[Callable] = None):\n        \"\"\"\n        –û–∑–≤—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Å —É–∫–∞–∑–∞–Ω–Ω–æ–π —ç–º–æ—Ü–∏–µ–π\n        \n        Args:\n            text: –¢–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è\n            emotion: –≠–º–æ—Ü–∏—è (neutral, excited, happy, sad, supportive, sarcastic, tense, gentle)\n            priority: –ï—Å–ª–∏ True, –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ä–µ—á—å\n            callback: –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ –ø–æ—Å–ª–µ –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è\n        \"\"\"\n        if not text or not text.strip():\n            return\n        \n        text = text.strip()\n        \n        if priority and self.is_speaking:\n            self.interrupt()\n        \n        self.speech_queue.put((text, emotion, priority, callback))\n        print(f\"[TTS] –í –æ—á–µ—Ä–µ–¥—å: '{text[:30]}...' (—ç–º–æ—Ü–∏—è: {emotion})\")\n    \n    def speak_with_pauses(self, text: str, emotion: str = 'neutral'):\n        \"\"\"–û–∑–≤—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –ø–∞—É–∑–∞–º–∏ –º–µ–∂–¥—É –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è–º–∏\"\"\"\n        sentences = text.replace('!', '.').replace('?', '.').split('.')\n        sentences = [s.strip() for s in sentences if s.strip()]\n        \n        for sentence in sentences:\n            self.speak(sentence, emotion)\n    \n    def interrupt(self):\n        \"\"\"–ü—Ä–µ—Ä–≤–∞—Ç—å —Ç–µ–∫—É—â—É—é —Ä–µ—á—å\"\"\"\n        if PYGAME_AVAILABLE and pygame.mixer.get_init():\n            pygame.mixer.music.stop()\n        \n        while not self.speech_queue.empty():\n            try:\n                self.speech_queue.get_nowait()\n                self.speech_queue.task_done()\n            except:\n                break\n    \n    def is_busy(self) -> bool:\n        \"\"\"–ü—Ä–æ–≤–µ—Ä–∫–∞, –≥–æ–≤–æ—Ä–∏—Ç –ª–∏ —Å–µ–π—á–∞—Å\"\"\"\n        return self.is_speaking or not self.speech_queue.empty()\n    \n    def set_voice(self, voice: str):\n        \"\"\"–°–º–µ–Ω–∏—Ç—å –≥–æ–ª–æ—Å\"\"\"\n        self.voice_name = self.VOICES.get(voice, voice)\n        print(f\"[TTS] –ì–æ–ª–æ—Å –∏–∑–º–µ–Ω—ë–Ω –Ω–∞: {self.voice_name}\")\n    \n    def set_rate(self, rate: int):\n        \"\"\"–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å —Ä–µ—á–∏ (-50 –¥–æ +50)\"\"\"\n        self.base_rate = max(-50, min(50, rate))\n    \n    def set_volume(self, volume: float):\n        \"\"\"–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥—Ä–æ–º–∫–æ—Å—Ç—å (0.0-1.0)\"\"\"\n        self.base_volume = max(0.0, min(1.0, volume))\n    \n    def stop(self):\n        \"\"\"–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–≤–∏–∂–æ–∫\"\"\"\n        self.stop_flag = True\n        self.interrupt()\n        \n        if PYGAME_AVAILABLE and pygame.mixer.get_init():\n            pygame.mixer.quit()\n        \n        print(\"[TTS] –î–≤–∏–∂–æ–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\")\n    \n    @staticmethod\n    async def list_voices(lang_filter: str = 'ru') -> list:\n        \"\"\"–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥–æ–ª–æ—Å–æ–≤\"\"\"\n        if not EDGE_TTS_AVAILABLE:\n            return []\n        \n        try:\n            voices = await edge_tts.list_voices()\n            if lang_filter:\n                voices = [v for v in voices if lang_filter.lower() in v['Locale'].lower()]\n            return voices\n        except Exception as e:\n            print(f\"[TTS] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥–æ–ª–æ—Å–æ–≤: {e}\")\n            return []\n\n\ndef synthesize_and_play(text: str, lang: str = 'ru', cleanup: bool = True) -> bool:\n    \"\"\"\n    –ë—ã—Å—Ç—Ä–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∏–Ω—Ç–µ–∑–∞ –∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è\n    –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º API\n    \"\"\"\n    engine = TTSEngine(voice='ru_female_soft')\n    engine.speak(text, emotion='neutral')\n    \n    while engine.is_busy():\n        time.sleep(0.1)\n    \n    engine.stop()\n    return True\n\n\nif __name__ == \"__main__\":\n    print(\"=== –¢–µ—Å—Ç TTS Engine ===\")\n    \n    tts = TTSEngine(voice='ru_female_soft')\n    \n    print(\"\\n–¢–µ—Å—Ç 1: –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π –≥–æ–ª–æ—Å\")\n    tts.speak(\"–ü—Ä–∏–≤–µ—Ç! –Ø –ò—Ä–∏—Å, —Ç–≤–æ–π –≥–æ–ª–æ—Å–æ–≤–æ–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç.\", emotion='neutral')\n    \n    while tts.is_busy():\n        time.sleep(0.1)\n    \n    print(\"\\n–¢–µ—Å—Ç 2: –í–∑–≤–æ–ª–Ω–æ–≤–∞–Ω–Ω—ã–π –≥–æ–ª–æ—Å\")\n    tts.speak(\"–£—Ö —Ç—ã! –û—Ç–ª–∏—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª! –ö—Ä–∞—Å–∞–≤—á–∏–∫!\", emotion='excited')\n    \n    while tts.is_busy():\n        time.sleep(0.1)\n    \n    print(\"\\n–¢–µ—Å—Ç 3: –ù–µ–∂–Ω—ã–π –≥–æ–ª–æ—Å\")\n    tts.speak(\"–ù–µ –ø–µ—Ä–µ–∂–∏–≤–∞–π, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ–ª—É—á–∏—Ç—Å—è.\", emotion='gentle')\n    \n    while tts.is_busy():\n        time.sleep(0.1)\n    \n    tts.stop()\n    print(\"\\n=== –¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω ===\")\n","path":null,"size_bytes":13274,"size_tokens":null},"src/utils/__init__.py":{"content":"\"\"\"\nIris Utils - –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã\n\"\"\"\n\ndef synthesize_and_play(text: str, lang: str = 'ru', cleanup: bool = True) -> bool:\n    \"\"\"\n    –ë—ã—Å—Ç—Ä–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∏–Ω—Ç–µ–∑–∞ –∏ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è\n    –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º API\n    \"\"\"\n    from src.tts_engine import TTSEngine\n    import time\n    \n    engine = TTSEngine(voice='ru_female_soft')\n    engine.speak(text, emotion='neutral')\n    \n    while engine.is_busy():\n        time.sleep(0.1)\n    \n    engine.stop()\n    return True\n\n__all__ = ['synthesize_and_play']\n","path":null,"size_bytes":593,"size_tokens":null},"main.py":{"content":"\"\"\"\nIRIS - AI Stream Companion\n–ì–æ–ª–æ—Å–æ–≤–æ–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤ —Å CS2 –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π\n–ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ (Edge TTS, Vosk, Groq)\n\"\"\"\nimport os\nimport sys\nimport time\nimport threading\nimport signal\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nfrom src.tts_engine import TTSEngine\nfrom src.voice_input import VoiceInput\nfrom src.cs2_gsi import CS2GameStateIntegration, GameEvent\nfrom src.streamelements_client import StreamElementsClient, StreamEvent\nfrom src.iris_brain import IrisBrain\nfrom src.windows_audio import WindowsAudioController\nfrom src.achievements import AchievementSystem, Achievement\n\n\nclass IrisAssistant:\n    \"\"\"\n    –ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å –ò—Ä–∏—Å - AI –∫–æ–º–ø–∞–Ω—å–æ–Ω–∞ –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤\n    \"\"\"\n    \n    def __init__(self):\n        print(\"=\" * 60)\n        print(\"üå∏ –ó–∞–ø—É—Å–∫ –ò—Ä–∏—Å - AI Stream Companion\")\n        print(\"=\" * 60)\n        print()\n\n        self.CONFIG = {\n            \"cs2_gsi_port\": 3000,\n            \"voice_wake_word\": \"–∏—Ä–∏—Å\",\n            \"voice_sensitivity\": 0.8,\n            \"tts_voice\": \"ru_female_soft\",\n            \"tts_rate\": 0,\n            \"tts_volume\": 0.9,\n        }\n        \n        self.is_running = False\n\n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TTS (–Ω–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å)...\")\n        self.tts = TTSEngine(\n            voice=self.CONFIG[\"tts_voice\"],\n            rate=self.CONFIG[\"tts_rate\"],\n            volume=self.CONFIG[\"tts_volume\"]\n        )\n\n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è AI –º–æ–∑–≥–∞...\")\n        self.iris_brain = IrisBrain()\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è CS2 Game State Integration...\")\n        self.cs2_gsi = CS2GameStateIntegration(\n            port=self.CONFIG[\"cs2_gsi_port\"],\n            event_callback=self._on_cs2_event\n        )\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞...\")\n        self.audio_controller = WindowsAudioController()\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞...\")\n        self.voice_input = VoiceInput(\n            wake_word=self.CONFIG[\"voice_wake_word\"],\n            sensitivity=self.CONFIG[\"voice_sensitivity\"]\n        )\n        self.voice_input.set_command_callback(self.process_voice_command)\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π...\")\n        self.achievements = AchievementSystem(\n            achievement_callback=self._on_achievement\n        )\n        \n        print(\"[IRIS] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è StreamElements –∫–ª–∏–µ–Ω—Ç–∞...\")\n        self.stream_elements = StreamElementsClient(\n            event_callback=self._on_stream_event\n        )\n        \n        print()\n        print(\"[IRIS] ‚úÖ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã\")\n        \n    def _on_wake_word(self):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è wake word\"\"\"\n        print(\"[IRIS] Wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω!\")\n        self.tts.speak(\"–î–∞?\", emotion='neutral', priority=True)\n        \n    def process_voice_command(self, command: str):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥\"\"\"\n        print(f\"[IRIS] üí¨ –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞: '{command}'\")\n        \n        if not command or command.strip() == \"\":\n            response = \"–î–∞, —è –∑–¥–µ—Å—å! –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?\"\n            self.tts.speak(response, emotion='gentle')\n            return\n        \n        command_lower = command.lower().strip()\n        \n        audio_keywords = ['–≥—Ä–æ–º–∫–æ—Å—Ç—å', '—Ç–∏—à–µ', '–≥—Ä–æ–º—á–µ', '–≤—ã–∫–ª—é—á–∏', '–≤–∫–ª—é—á–∏', '–º—É–∑—ã–∫', '–∑–≤—É–∫', 'mute']\n        if any(kw in command_lower for kw in audio_keywords):\n            response = self.audio_controller.execute_voice_command(command)\n            self.tts.speak(response, emotion='neutral')\n            return\n        \n        if '–ø—Ä–∏–≤–µ—Ç' in command_lower:\n            response = \"–ü—Ä–∏–≤–µ—Ç! –Ø –ò—Ä–∏—Å, —Ç–≤–æ—è AI-–ø–æ–¥—Ä—É–≥–∞ –Ω–∞ —Å—Ç—Ä–∏–º–µ!\"\n            self.tts.speak(response, emotion='happy')\n            return\n            \n        if '–∫–∞–∫ –¥–µ–ª–∞' in command_lower or '–∫–∞–∫ —Ç—ã' in command_lower:\n            response = \"–û—Ç–ª–∏—á–Ω–æ! –ì–æ—Ç–æ–≤–∞ —Å–ª–µ–¥–∏—Ç—å –∑–∞ –∏–≥—Ä–æ–π –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å —Ç–µ–±—è!\"\n            self.tts.speak(response, emotion='happy')\n            return\n            \n        if '—Ç–µ—Å—Ç' in command_lower:\n            response = \"–¢–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω! –ì–æ–ª–æ—Å–æ–≤–æ–π –ø–æ–º–æ—â–Ω–∏–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –æ—Ç–ª–∏—á–Ω–æ.\"\n            self.tts.speak(response, emotion='neutral')\n            return\n            \n        if '—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞' in command_lower or '—Å—Ç–∞—Ç–∞' in command_lower:\n            stats = self.achievements.get_stats_summary()\n            self.tts.speak(f\"–í–æ—Ç —Ç–≤–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {stats[:200]}\", emotion='neutral')\n            return\n            \n        if '–¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è' in command_lower:\n            progress = self.achievements.get_progress_summary()\n            self.tts.speak(progress, emotion='neutral')\n            return\n            \n        if command_lower in ['—Å—Ç–æ–ø', '–æ—Å—Ç–∞–Ω–æ–≤–∏—Å—å', '–≤—ã—Ö–æ–¥', '–ø–æ–∫–∞']:\n            response = \"–î–æ –≤—Å—Ç—Ä–µ—á–∏! –ë—ã–ª–æ –≤–µ—Å–µ–ª–æ!\"\n            self.tts.speak(response, emotion='gentle')\n            time.sleep(2)\n            self.stop()\n            return\n        \n        try:\n            response = self.iris_brain.chat_with_user(command)\n            if response:\n                self.tts.speak(response, emotion='neutral')\n            else:\n                self.tts.speak(f\"–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ! –¢—ã —Å–∫–∞–∑–∞–ª: {command}\", emotion='neutral')\n        except Exception as e:\n            print(f\"[IRIS] –û—à–∏–±–∫–∞ AI: {e}\")\n            self.tts.speak(\"–•–º, –¥–∞–π –º–Ω–µ —Å–µ–∫—É–Ω–¥—É –ø–æ–¥—É–º–∞—Ç—å...\", emotion='neutral')\n            \n    def _on_cs2_event(self, event: GameEvent):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π CS2\"\"\"\n        print(f\"[CS2] –°–æ–±—ã—Ç–∏–µ: {event.event_type}\")\n        \n        self.iris_brain.update_context(\n            map_name=self.cs2_gsi.map.name,\n            ct_score=self.cs2_gsi.map.ct_score,\n            t_score=self.cs2_gsi.map.t_score,\n            player_stats=self.cs2_gsi.get_player_stats(),\n            event={'type': event.event_type, 'data': event.data}\n        )\n        \n        response = None\n        emotion = 'neutral'\n        \n        if event.event_type == 'ace':\n            self.achievements.record_kill(round_kills=5)\n            response = self.iris_brain.react_to_kill(event.data)\n            emotion = 'excited'\n            \n        elif event.event_type in ['kill', 'double_kill', 'triple_kill', 'quadra_kill']:\n            is_headshot = event.data.get('headshot', False)\n            round_kills = event.data.get('round_kills', 1)\n            self.achievements.record_kill(headshot=is_headshot, round_kills=round_kills)\n            response = self.iris_brain.react_to_kill(event.data)\n            emotion = 'excited' if round_kills >= 3 else 'happy'\n            \n        elif event.event_type == 'death':\n            self.achievements.record_death()\n            response = self.iris_brain.react_to_death(event.data)\n            emotion = 'supportive'\n            \n        elif event.event_type == 'round_end':\n            won = event.data.get('won', False)\n            clutch = event.data.get('clutch_win', False)\n            if won:\n                self.achievements.record_round_win(clutch=clutch)\n            else:\n                self.achievements.record_round_loss()\n            response = self.iris_brain.react_to_round_end(event.data)\n            emotion = 'excited' if won else 'supportive'\n            \n        elif event.event_type == 'low_health':\n            health = event.data.get('current_health', 100)\n            self.achievements.record_low_health_survive(health)\n            \n        elif event.event_type in ['bomb_planted', 'bomb_defused', 'bomb_exploded']:\n            if event.event_type == 'bomb_defused' and event.data.get('ninja_defuse'):\n                self.achievements.record_ninja_defuse()\n            response = self.iris_brain.react_to_bomb_event(event.event_type, event.data)\n            emotion = 'tense' if event.event_type == 'bomb_planted' else 'excited'\n            \n        elif event.event_type == 'match_end':\n            won = event.data.get('won', False)\n            self.achievements.record_match_end(won=won)\n            \n        if response:\n            self.tts.speak(response, emotion=emotion)\n            \n    def _on_stream_event(self, event: StreamEvent):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π —Å—Ç—Ä–∏–º–∞\"\"\"\n        print(f\"[STREAM] –°–æ–±—ã—Ç–∏–µ: {event.event_type}\")\n        \n        response = None\n        emotion = 'neutral'\n        \n        if event.event_type == 'donation':\n            amount = event.data.get('amount', 0)\n            currency = event.data.get('currency', 'RUB')\n            self.achievements.record_donation(amount, currency)\n            response = self.iris_brain.react_to_donation(event.data)\n            emotion = 'excited'\n            \n        elif event.event_type == 'subscription':\n            self.achievements.record_subscription()\n            response = self.iris_brain.react_to_subscription(event.data)\n            emotion = 'excited'\n            \n        elif event.event_type == 'raid':\n            viewers = event.data.get('viewers', 0)\n            self.achievements.record_raid(viewers)\n            response = self.iris_brain.react_to_raid(event.data)\n            emotion = 'excited'\n            \n        elif event.event_type == 'chat_message':\n            self.achievements.record_chat_message()\n            response = self.iris_brain.react_to_chat_message(event.data)\n            \n        elif event.event_type == 'follow':\n            pass\n            \n        if response:\n            self.tts.speak(response, emotion=emotion)\n            \n    def _on_achievement(self, achievement: Achievement):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π\"\"\"\n        message = f\"–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ! {achievement.icon} {achievement.name}!\"\n        self.tts.speak(message, emotion='excited', priority=True)\n        \n    def _random_comment_loop(self):\n        \"\"\"–¶–∏–∫–ª —Å–ª—É—á–∞–π–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤\"\"\"\n        while self.is_running:\n            time.sleep(120)\n            \n            if not self.is_running:\n                break\n                \n            self.achievements.check_time_achievements()\n            \n            if not self.tts.is_busy():\n                comment = self.iris_brain.generate_random_comment()\n                if comment:\n                    self.tts.speak(comment, emotion='neutral')\n                    \n    def start(self):\n        \"\"\"–ó–∞–ø—É—Å–∫ –ò—Ä–∏—Å\"\"\"\n        self.is_running = True\n        \n        print(\"\\n[IRIS] –ó–∞–ø—É—Å–∫ CS2 Game State Integration...\")\n        self.cs2_gsi.start()\n        self.cs2_gsi.save_config_file()\n        \n        jwt_token = os.getenv('STREAMELEMENTS_JWT_TOKEN', '')\n        if jwt_token:\n            print(\"\\n[IRIS] –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ StreamElements...\")\n            self.stream_elements.connect()\n        else:\n            print(\"\\n[IRIS] ‚ö†Ô∏è STREAMELEMENTS_JWT_TOKEN –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω - —á–∞—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω\")\n            \n        groq_key = os.getenv('GROQ_API_KEY', '')\n        if not groq_key:\n            print(\"\\n[IRIS] ‚ö†Ô∏è GROQ_API_KEY –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω - AI –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å fallback –æ—Ç–≤–µ—Ç—ã\")\n            \n        print(\"\\n[IRIS] –ó–∞–ø—É—Å–∫ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞...\")\n        self.voice_input.start()\n        \n        self.random_comment_thread = threading.Thread(\n            target=self._random_comment_loop,\n            daemon=True\n        )\n        self.random_comment_thread.start()\n        \n        print(\"\\n\" + \"=\" * 60)\n        print(\"üå∏ –ò—Ä–∏—Å —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞!\")\n        print(\"=\" * 60)\n        print()\n        print(\"üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:\")\n        print(\"   üéÆ CS2 Game State Integration (–ø–æ—Ä—Ç 3000)\")\n        print(\"   üí¨ StreamElements —á–∞—Ç –∏ –¥–æ–Ω–∞—Ç—ã\")\n        print(\"   üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (—Å–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å')\")\n        print(\"   üîä –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π\")\n        print(\"   üèÜ –°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π\")\n        print()\n        print(\"üé§ –ì–æ–ª–æ—Å: –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π (Edge TTS)\")\n        print(\"üß† AI: Groq LLM (–±–µ—Å–ø–ª–∞—Ç–Ω–æ)\")\n        print()\n        print(\"–ù–∞–∂–º–∏—Ç–µ Ctrl+C –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\")\n        print(\"=\" * 60)\n        \n        self.tts.speak(\"–ü—Ä–∏–≤–µ—Ç! –Ø –ò—Ä–∏—Å, –≥–æ—Ç–æ–≤–∞ –∫ —Å—Ç—Ä–∏–º—É!\", emotion='happy')\n        \n    def stop(self):\n        \"\"\"–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ò—Ä–∏—Å\"\"\"\n        print(\"\\n[IRIS] –û—Å—Ç–∞–Ω–æ–≤–∫–∞...\")\n        self.is_running = False\n        \n        self.achievements.save_stats()\n        \n        self.voice_input.stop()\n        self.stream_elements.disconnect()\n        self.cs2_gsi.stop()\n        self.tts.stop()\n        \n        print(\"[IRIS] –î–æ –≤—Å—Ç—Ä–µ—á–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–º —Å—Ç—Ä–∏–º–µ! üå∏\")\n        \n    def run(self):\n        \"\"\"–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª\"\"\"\n        def signal_handler(sig, frame):\n            self.stop()\n            sys.exit(0)\n            \n        signal.signal(signal.SIGINT, signal_handler)\n        signal.signal(signal.SIGTERM, signal_handler)\n        \n        self.start()\n        \n        try:\n            while self.is_running:\n                time.sleep(1)\n        except KeyboardInterrupt:\n            self.stop()\n\n\ndef main():\n    \"\"\"–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞\"\"\"\n    print()\n    print(\"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\")\n    print(\"‚ïë                                                            ‚ïë\")\n    print(\"‚ïë   üå∏ IRIS - AI Stream Companion                            ‚ïë\")\n    print(\"‚ïë   –ì–æ–ª–æ—Å–æ–≤–æ–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤                         ‚ïë\")\n    print(\"‚ïë                                                            ‚ïë\")\n    print(\"‚ïë   üíú –ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏:                      ‚ïë\")\n    print(\"‚ïë      ‚Ä¢ Edge TTS - –Ω–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å                    ‚ïë\")\n    print(\"‚ïë      ‚Ä¢ Vosk - –æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏                   ‚ïë\")\n    print(\"‚ïë      ‚Ä¢ Groq LLM - –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π AI                           ‚ïë\")\n    print(\"‚ïë                                                            ‚ïë\")\n    print(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\")\n    print()\n    \n    iris = IrisAssistant()\n    iris.run()\n\n\nif __name__ == \"__main__\":\n    main()\n","path":null,"size_bytes":15214,"size_tokens":null},"src/voice_recognition.py":{"content":"import os\nimport time\nimport threading\nimport queue\n\ntry:\n    import speech_recognition as sr\n    SR_AVAILABLE = True\nexcept ImportError:\n    SR_AVAILABLE = False\n    print(\"[VOICE] SpeechRecognition –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\")\n\nPYAUDIO_AVAILABLE = False\ntry:\n    import pyaudio\n    PYAUDIO_AVAILABLE = True\nexcept ImportError:\n    print(\"[VOICE] PyAudio –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - –≥–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –º–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ\")\n\nclass VoiceRecognition:\n    WAKE_WORDS = ['–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏—Å–∏–∫', '—ç–π –∏—Ä–∏—Å', 'hey iris', '–∏—Ä–∏—Å–∫–∞']\n    \n    def __init__(self, \n                 wake_word_callback=None,\n                 command_callback=None,\n                 language: str = \"ru-RU\"):\n        \n        self.wake_word_callback = wake_word_callback\n        self.command_callback = command_callback\n        self.language = language\n        \n        self.is_listening = False\n        self.conversation_mode = False\n        self.conversation_timeout = 30.0\n        self.last_interaction_time = 0\n        \n        if SR_AVAILABLE and PYAUDIO_AVAILABLE:\n            self.recognizer = sr.Recognizer()\n            self.recognizer.energy_threshold = 300\n            self.recognizer.dynamic_energy_threshold = True\n            self.recognizer.pause_threshold = 0.8\n        else:\n            self.recognizer = None\n            \n        self.listen_thread = None\n            \n    def start_listening(self):\n        if not SR_AVAILABLE or not PYAUDIO_AVAILABLE:\n            print(\"[VOICE] –ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥\")\n            return False\n            \n        self.is_listening = True\n        self.listen_thread = threading.Thread(target=self._listen_loop, daemon=True)\n        self.listen_thread.start()\n        \n        print(\"[VOICE] –°–ª—É—à–∞—é... –°–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å' –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏\")\n        return True\n        \n    def stop_listening(self):\n        self.is_listening = False\n        self.conversation_mode = False\n        \n    def _listen_loop(self):\n        try:\n            with sr.Microphone() as source:\n                print(\"[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...\")\n                self.recognizer.adjust_for_ambient_noise(source, duration=1)\n                print(\"[VOICE] –ì–æ—Ç–æ–≤ –∫ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—é!\")\n                \n                while self.is_listening:\n                    try:\n                        audio = self.recognizer.listen(source, timeout=5, phrase_time_limit=10)\n                        \n                        threading.Thread(\n                            target=self._process_audio, \n                            args=(audio,),\n                            daemon=True\n                        ).start()\n                        \n                    except sr.WaitTimeoutError:\n                        if self.conversation_mode:\n                            if time.time() - self.last_interaction_time > self.conversation_timeout:\n                                self.conversation_mode = False\n                                print(\"[VOICE] –†–µ–∂–∏–º —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∑–∞–≤–µ—Ä—à—ë–Ω –ø–æ —Ç–∞–π–º–∞—É—Ç—É\")\n                        continue\n                    except Exception as e:\n                        print(f\"[VOICE] –û—à–∏–±–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è: {e}\")\n                        continue\n                        \n        except Exception as e:\n            print(f\"[VOICE] –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}\")\n            \n    def _process_audio(self, audio):\n        try:\n            text = self.recognizer.recognize_google(audio, language=self.language)\n            text = text.lower().strip()\n            \n            if not text:\n                return\n                \n            print(f\"[VOICE] –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: {text}\")\n            self._handle_transcription(text)\n            \n        except sr.UnknownValueError:\n            pass\n        except sr.RequestError as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: {e}\")\n        except Exception as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}\")\n            \n    def _handle_transcription(self, text: str):\n        if self.conversation_mode:\n            self.last_interaction_time = time.time()\n            if self.command_callback:\n                self.command_callback(text, is_conversation=True)\n            return\n            \n        for wake_word in self.WAKE_WORDS:\n            if wake_word in text:\n                self.conversation_mode = True\n                self.last_interaction_time = time.time()\n                \n                command = text\n                for ww in self.WAKE_WORDS:\n                    command = command.replace(ww, '').strip()\n                    \n                print(f\"[VOICE] Wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω! –ö–æ–º–∞–Ω–¥–∞: {command}\")\n                \n                if self.wake_word_callback:\n                    self.wake_word_callback()\n                    \n                if command and self.command_callback:\n                    self.command_callback(command, is_conversation=False)\n                elif self.command_callback:\n                    self.command_callback(\"\", is_conversation=False)\n                    \n                return\n                \n    def set_conversation_mode(self, enabled: bool):\n        self.conversation_mode = enabled\n        if enabled:\n            self.last_interaction_time = time.time()\n            \n    def is_in_conversation(self) -> bool:\n        return self.conversation_mode\n        \n\nclass TextInputFallback:\n    def __init__(self, command_callback=None):\n        self.command_callback = command_callback\n        self.is_listening = False\n        self.input_thread = None\n        \n    def start_listening(self):\n        self.is_listening = True\n        self.input_thread = threading.Thread(target=self._input_loop, daemon=True)\n        self.input_thread.start()\n        print(\"[TEXT] –¢–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω. –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É:\")\n        return True\n        \n    def stop_listening(self):\n        self.is_listening = False\n        \n    def _input_loop(self):\n        while self.is_listening:\n            try:\n                user_input = input(\"> \").strip()\n                if user_input and self.command_callback:\n                    self.command_callback(user_input, is_conversation=True)\n            except EOFError:\n                break\n            except Exception as e:\n                print(f\"[TEXT] –û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞: {e}\")\n                time.sleep(1)\n","path":null,"size_bytes":6642,"size_tokens":null},"src/voice_input.py":{"content":"\"\"\"\nIris Voice Input - –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –≥–æ–ª–æ—Å–∞ —Å Vosk\n–û—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Å –≤—ã—Å–æ–∫–æ–π —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –∫ wake-word '–ò—Ä–∏—Å'\n\"\"\"\nimport threading\nimport time\nimport queue\nimport os\nimport json\nimport logging\nfrom typing import Optional, Callable, List\nfrom pathlib import Path\n\ntry:\n    from vosk import Model, KaldiRecognizer, SetLogLevel\n    SetLogLevel(-1)\n    VOSK_AVAILABLE = True\nexcept ImportError:\n    VOSK_AVAILABLE = False\n    print(\"[VOICE] Vosk –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install vosk\")\n\nSOUNDDEVICE_AVAILABLE = False\nsd = None\nnp = None\ntry:\n    import numpy as np\n    import sounddevice as sd\n    sd.query_devices()\n    SOUNDDEVICE_AVAILABLE = True\nexcept (ImportError, OSError, Exception) as e:\n    SOUNDDEVICE_AVAILABLE = False\n    sd = None\n    try:\n        import numpy as np\n    except ImportError:\n        np = None\n    print(f\"[VOICE] sounddevice –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}\")\n\ntry:\n    import speech_recognition as sr\n    SR_AVAILABLE = True\nexcept ImportError:\n    SR_AVAILABLE = False\n    print(\"[VOICE] speech_recognition –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ: pip install SpeechRecognition\")\n\nlogger = logging.getLogger('VoiceInput')\n\n\nclass VoiceInput:\n    \"\"\"\n    –£–ª—É—á—à–µ–Ω–Ω—ã–π –º–æ–¥—É–ª—å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–∞\n    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç Vosk (–æ—Ñ–ª–∞–π–Ω) –∏ Google Speech Recognition (–æ–Ω–ª–∞–π–Ω)\n    \"\"\"\n    \n    WAKE_WORD_VARIANTS = [\n        '–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏', '–∏—Ä–∏—Å–∫–∞', '–∏—Ä–∏—Å—Å', '–∏—Ä–∏—Å–∞',\n        '–∞–π—Ä–∏—Å', '–∞—Ä–∏—Å', '–∏—Ä–∏—à', '–∏—Ä–∏—Å—å', '—Ä–∏—Å', '—ç—Ä–∏—Å'\n    ]\n    \n    def __init__(self, \n                 wake_word: str = \"–∏—Ä–∏—Å\",\n                 sensitivity: float = 0.7,\n                 use_vosk: bool = True,\n                 vosk_model_path: str = None,\n                 sample_rate: int = 16000):\n        \"\"\"\n        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–∞\n        \n        Args:\n            wake_word: –ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏\n            sensitivity: –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (0.0-1.0)\n            use_vosk: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Vosk –¥–ª—è –æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è\n            vosk_model_path: –ü—É—Ç—å –∫ –º–æ–¥–µ–ª–∏ Vosk\n            sample_rate: –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏\n        \"\"\"\n        self.wake_word = wake_word.lower()\n        self.sensitivity = max(0.1, min(1.0, sensitivity))\n        self.sample_rate = sample_rate\n        self.use_vosk = use_vosk and VOSK_AVAILABLE\n        \n        self.command_queue = queue.Queue()\n        self.is_listening = False\n        self.is_calibrating = False\n        self.listener_thread: Optional[threading.Thread] = None\n        self.command_callback: Optional[Callable] = None\n        \n        self.recognition_history: List[str] = []\n        self.max_history = 50\n        self.wake_word_detected_count = 0\n        self.total_phrases_count = 0\n        \n        self.vosk_model = None\n        self.recognizer = None\n        \n        self.energy_threshold = 1500 + (3500 * (1 - sensitivity))\n        self.silence_threshold = 0.3\n        self.phrase_timeout = 3.0\n        \n        if self.use_vosk:\n            self._init_vosk(vosk_model_path)\n        \n        if SR_AVAILABLE:\n            self._init_speech_recognition()\n        \n        print(f\"[VOICE] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å wake word: '{self.wake_word}'\")\n        print(f\"[VOICE] –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {self.sensitivity}\")\n        print(f\"[VOICE] Vosk –¥–æ—Å—Ç—É–ø–µ–Ω: {VOSK_AVAILABLE}\")\n        print(f\"[VOICE] SoundDevice –¥–æ—Å—Ç—É–ø–µ–Ω: {SOUNDDEVICE_AVAILABLE}\")\n    \n    def _init_vosk(self, model_path: str = None):\n        \"\"\"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Vosk –º–æ–¥–µ–ª–∏\"\"\"\n        if not VOSK_AVAILABLE:\n            return\n        \n        model_paths = [\n            model_path,\n            'models/vosk-model-small-ru',\n            'vosk-model-small-ru-0.22',\n            os.path.expanduser('~/.vosk/vosk-model-small-ru'),\n            '/usr/share/vosk/vosk-model-small-ru',\n        ]\n        \n        for path in model_paths:\n            if path and os.path.exists(path):\n                try:\n                    self.vosk_model = Model(path)\n                    self.recognizer = KaldiRecognizer(self.vosk_model, self.sample_rate)\n                    self.recognizer.SetWords(True)\n                    print(f\"[VOICE] Vosk –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {path}\")\n                    return\n                except Exception as e:\n                    print(f\"[VOICE] –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏ {path}: {e}\")\n        \n        print(\"[VOICE] Vosk –º–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–Ω–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ.\")\n        self.use_vosk = False\n    \n    def _init_speech_recognition(self):\n        \"\"\"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è speech_recognition\"\"\"\n        if not SR_AVAILABLE:\n            return\n        \n        self.sr_recognizer = sr.Recognizer()\n        self.sr_recognizer.pause_threshold = 0.5\n        self.sr_recognizer.phrase_threshold = 0.3\n        self.sr_recognizer.non_speaking_duration = 0.3\n        self.sr_recognizer.energy_threshold = self.energy_threshold\n        self.sr_recognizer.dynamic_energy_threshold = False\n    \n    def _check_wake_word(self, text: str) -> bool:\n        \"\"\"\n        –£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ wake word —Å fuzzy matching\n        \n        Args:\n            text: –†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç\n            \n        Returns:\n            bool: True –µ—Å–ª–∏ wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω\n        \"\"\"\n        if not text:\n            return False\n        \n        text_lower = text.lower().strip()\n        words = text_lower.split()\n        \n        for variant in self.WAKE_WORD_VARIANTS:\n            if variant in text_lower:\n                logger.debug(f\"Wake word –Ω–∞–π–¥–µ–Ω (—Ç–æ—á–Ω–æ–µ): '{variant}' –≤ '{text}'\")\n                return True\n        \n        for word in words:\n            if len(word) >= 3:\n                for variant in self.WAKE_WORD_VARIANTS:\n                    if word.startswith(variant[:3]) or variant.startswith(word[:3]):\n                        logger.debug(f\"Wake word –Ω–∞–π–¥–µ–Ω (—á–∞—Å—Ç–∏—á–Ω–æ–µ): '{word}' ~ '{variant}'\")\n                        return True\n        \n        if text_lower.startswith(self.wake_word[:2]):\n            logger.debug(f\"Wake word –Ω–∞–π–¥–µ–Ω (–Ω–∞—á–∞–ª–æ): '{text_lower[:5]}...'\")\n            return True\n        \n        wake_chars = set(self.wake_word)\n        for word in words:\n            if len(word) >= 3:\n                word_chars = set(word)\n                overlap = len(wake_chars & word_chars)\n                if overlap >= len(wake_chars) * 0.7:\n                    logger.debug(f\"Wake word –Ω–∞–π–¥–µ–Ω (—Å–∏–º–≤–æ–ª—ã): '{word}'\")\n                    return True\n        \n        return False\n    \n    def _extract_command(self, text: str) -> str:\n        \"\"\"\n        –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã –∏–∑ —Ç–µ–∫—Å—Ç–∞ –ø–æ—Å–ª–µ wake word\n        \n        Args:\n            text: –†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç\n            \n        Returns:\n            str: –ö–æ–º–∞–Ω–¥–∞ –∏–ª–∏ –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞\n        \"\"\"\n        if not text:\n            return \"\"\n        \n        text_lower = text.lower().strip()\n        \n        for variant in sorted(self.WAKE_WORD_VARIANTS, key=len, reverse=True):\n            if variant in text_lower:\n                parts = text_lower.split(variant, 1)\n                if len(parts) > 1:\n                    return parts[1].strip()\n        \n        if text_lower.startswith(self.wake_word):\n            return text_lower[len(self.wake_word):].strip()\n        \n        return text_lower\n    \n    def _recognize_with_vosk(self, audio_data: bytes) -> Optional[str]:\n        \"\"\"–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é Vosk\"\"\"\n        if not self.recognizer:\n            return None\n        \n        try:\n            if self.recognizer.AcceptWaveform(audio_data):\n                result = json.loads(self.recognizer.Result())\n                return result.get('text', '')\n            else:\n                partial = json.loads(self.recognizer.PartialResult())\n                return partial.get('partial', '')\n        except Exception as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ Vosk: {e}\")\n            return None\n    \n    def _recognize_with_google(self, audio) -> Optional[str]:\n        \"\"\"–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é Google Speech API\"\"\"\n        if not SR_AVAILABLE:\n            return None\n        \n        try:\n            text = self.sr_recognizer.recognize_google(audio, language=\"ru-RU\")\n            return text\n        except sr.UnknownValueError:\n            return None\n        except sr.RequestError as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ Google Speech: {e}\")\n            return None\n    \n    def _process_recognition(self, text: str):\n        \"\"\"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞\"\"\"\n        if not text or len(text.strip()) < 2:\n            return\n        \n        self.total_phrases_count += 1\n        self.recognition_history.append(text)\n        if len(self.recognition_history) > self.max_history:\n            self.recognition_history.pop(0)\n        \n        print(f\"[VOICE] –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: '{text}'\")\n        \n        if self._check_wake_word(text):\n            self.wake_word_detected_count += 1\n            print(f\"[VOICE] Wake word –æ–±–Ω–∞—Ä—É–∂–µ–Ω!\")\n            \n            command = self._extract_command(text)\n            print(f\"[VOICE] –ö–æ–º–∞–Ω–¥–∞: '{command}'\")\n            \n            self.command_queue.put(command)\n            \n            if self.command_callback:\n                try:\n                    self.command_callback(command)\n                except Exception as e:\n                    logger.error(f\"–û—à–∏–±–∫–∞ callback: {e}\")\n        \n        elif text.lower() in [\"—Å—Ç–æ–ø\", \"–æ—Å—Ç–∞–Ω–æ–≤–∏—Å—å\", \"–≤—ã—Ö–æ–¥\", \"stop\", \"exit\"]:\n            print(\"[VOICE] –ö–æ–º–∞–Ω–¥–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏\")\n            self.command_queue.put(\"—Å—Ç–æ–ø\")\n    \n    def _listen_loop_vosk(self):\n        \"\"\"–¶–∏–∫–ª –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è —Å Vosk –∏ sounddevice\"\"\"\n        if not SOUNDDEVICE_AVAILABLE or sd is None:\n            print(\"[VOICE] sounddevice –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ Google Speech...\")\n            self._listen_loop_sr()\n            return\n        \n        print(f\"[VOICE] –°–ª—É—à–∞—é —Å Vosk... (–°–∫–∞–∂–∏—Ç–µ '{self.wake_word}')\")\n        \n        def audio_callback(indata, frames, time_info, status):\n            if status:\n                logger.warning(f\"Audio status: {status}\")\n            \n            audio_bytes = (indata * 32767).astype(np.int16).tobytes()\n            \n            text = self._recognize_with_vosk(audio_bytes)\n            if text:\n                self._process_recognition(text)\n        \n        try:\n            with sd.InputStream(\n                samplerate=self.sample_rate,\n                channels=1,\n                dtype='float32',\n                blocksize=int(self.sample_rate * 0.5),\n                callback=audio_callback\n            ):\n                while self.is_listening:\n                    time.sleep(0.1)\n        except Exception as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ –ø–æ—Ç–æ–∫–∞ –∞—É–¥–∏–æ: {e}\")\n            print(\"[VOICE] –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ Google Speech –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤...\")\n            self._listen_loop_sr()\n    \n    def _listen_loop_sr(self):\n        \"\"\"–¶–∏–∫–ª –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è —Å speech_recognition\"\"\"\n        if not SR_AVAILABLE:\n            print(\"[VOICE] speech_recognition –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω\")\n            print(\"[VOICE] –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –æ—Ç–∫–ª—é—á–µ–Ω - –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞—É–¥–∏–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤\")\n            self.is_listening = False\n            return\n        \n        print(f\"[VOICE] –°–ª—É—à–∞—é —Å Google Speech... (–°–∫–∞–∂–∏—Ç–µ '{self.wake_word}')\")\n        \n        try:\n            with sr.Microphone() as source:\n                print(\"[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...\")\n                self.sr_recognizer.adjust_for_ambient_noise(source, duration=1)\n                print(\"[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞\")\n                \n                while self.is_listening:\n                    try:\n                        audio = self.sr_recognizer.listen(\n                            source,\n                            timeout=2,\n                            phrase_time_limit=5\n                        )\n                        \n                        text = self._recognize_with_google(audio)\n                        if text:\n                            self._process_recognition(text)\n                        \n                    except sr.WaitTimeoutError:\n                        continue\n                    except Exception as e:\n                        logger.error(f\"–û—à–∏–±–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è: {e}\")\n                        time.sleep(0.5)\n        \n        except OSError as e:\n            print(f\"[VOICE] –ù–µ—Ç –∞—É–¥–∏–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤: {e}\")\n            print(\"[VOICE] –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –æ—Ç–∫–ª—é—á–µ–Ω - —Ç—Ä–µ–±—É–µ—Ç—Å—è –º–∏–∫—Ä–æ—Ñ–æ–Ω\")\n            self.is_listening = False\n        except Exception as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞: {e}\")\n            self.is_listening = False\n    \n    def calibrate_microphone(self):\n        \"\"\"–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞\"\"\"\n        if self.is_calibrating:\n            return\n        \n        self.is_calibrating = True\n        print(\"[VOICE] –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...\")\n        \n        try:\n            if SR_AVAILABLE:\n                with sr.Microphone() as source:\n                    self.sr_recognizer.adjust_for_ambient_noise(source, duration=1)\n                    print(f\"[VOICE] –ü–æ—Ä–æ–≥ —ç–Ω–µ—Ä–≥–∏–∏: {self.sr_recognizer.energy_threshold}\")\n        except Exception as e:\n            print(f\"[VOICE] –û—à–∏–±–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏: {e}\")\n        finally:\n            self.is_calibrating = False\n    \n    def start(self):\n        \"\"\"–ó–∞–ø—É—Å–∫ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞\"\"\"\n        if self.is_listening:\n            print(\"[VOICE] –£–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç\")\n            return\n        \n        self.is_listening = True\n        \n        if self.use_vosk and self.vosk_model:\n            self.listener_thread = threading.Thread(\n                target=self._listen_loop_vosk,\n                daemon=True\n            )\n        else:\n            self.listener_thread = threading.Thread(\n                target=self._listen_loop_sr,\n                daemon=True\n            )\n        \n        self.listener_thread.start()\n        print(\"[VOICE] –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –∑–∞–ø—É—â–µ–Ω\")\n    \n    def stop(self):\n        \"\"\"–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞\"\"\"\n        self.is_listening = False\n        if self.listener_thread:\n            self.listener_thread.join(timeout=2)\n        print(\"[VOICE] –ì–æ–ª–æ—Å–æ–≤–æ–π –≤–≤–æ–¥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\")\n    \n    def stop_listening(self):\n        \"\"\"–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è (–∞–ª–∏–∞—Å –¥–ª—è stop)\"\"\"\n        self.stop()\n    \n    def get_command(self) -> Optional[str]:\n        \"\"\"–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–π –∫–æ–º–∞–Ω–¥—ã –∏–∑ –æ—á–µ—Ä–µ–¥–∏\"\"\"\n        try:\n            return self.command_queue.get_nowait()\n        except queue.Empty:\n            return None\n    \n    def set_command_callback(self, callback: Callable):\n        \"\"\"–£—Å—Ç–∞–Ω–æ–≤–∫–∞ callback –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥\"\"\"\n        self.command_callback = callback\n    \n    def set_sensitivity(self, sensitivity: float):\n        \"\"\"–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ (0.0-1.0)\"\"\"\n        self.sensitivity = max(0.1, min(1.0, sensitivity))\n        self.energy_threshold = 1500 + (3500 * (1 - self.sensitivity))\n        \n        if SR_AVAILABLE and hasattr(self, 'sr_recognizer'):\n            self.sr_recognizer.energy_threshold = self.energy_threshold\n        \n        print(f\"[VOICE] –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {self.sensitivity}, –ø–æ—Ä–æ–≥: {self.energy_threshold}\")\n    \n    def get_recognition_stats(self) -> dict:\n        \"\"\"–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è\"\"\"\n        return {\n            \"total_phrases\": self.total_phrases_count,\n            \"wake_detected\": self.wake_word_detected_count,\n            \"detection_rate\": self.wake_word_detected_count / max(1, self.total_phrases_count),\n            \"recent_phrases\": self.recognition_history[-10:],\n            \"sensitivity\": self.sensitivity,\n            \"energy_threshold\": self.energy_threshold\n        }\n\n\nif __name__ == \"__main__\":\n    print(\"=== –¢–µ—Å—Ç Voice Input ===\")\n    \n    def on_command(cmd):\n        print(f\"\\n>>> –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞: '{cmd}'\\n\")\n    \n    voice = VoiceInput(wake_word=\"–∏—Ä–∏—Å\", sensitivity=0.8)\n    voice.set_command_callback(on_command)\n    \n    print(\"\\n–°–∫–∞–∂–∏—Ç–µ '–ò—Ä–∏—Å' –∏ –∫–æ–º–∞–Ω–¥—É...\")\n    voice.start()\n    \n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        print(\"\\n–û—Å—Ç–∞–Ω–æ–≤–∫–∞...\")\n        voice.stop()\n        \n        stats = voice.get_recognition_stats()\n        print(f\"\\n–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\")\n        print(f\"  –í—Å–µ–≥–æ —Ñ—Ä–∞–∑: {stats['total_phrases']}\")\n        print(f\"  Wake word: {stats['wake_detected']}\")\n        print(f\"  –¢–æ—á–Ω–æ—Å—Ç—å: {stats['detection_rate']:.1%}\")\n","path":null,"size_bytes":17625,"size_tokens":null},"src/iris_brain.py":{"content":"\"\"\"\nIRIS BRAIN - AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤\n–Ø–¥—Ä–æ –ò–ò-–ª–æ–≥–∏–∫–∏ –¥–ª—è —Ä–µ–∞–∫—Ü–∏–π –Ω–∞ –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å —á–∞—Ç–æ–º\n–í–µ—Ä—Å–∏—è: 2.0\n–ê–≤—Ç–æ—Ä: [–í–∞—à–µ –∏–º—è]\n\"\"\"\n\nimport os\nimport time\nimport random\nimport json\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Any, Tuple\nfrom collections import deque, defaultdict\nfrom dataclasses import dataclass, asdict\nfrom enum import Enum\nfrom groq import Groq\n\n\n# ===================== –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ì–ò–†–û–í–ê–ù–ò–Ø =====================\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('iris_brain.log', encoding='utf-8'),\n        logging.StreamHandler()\n    ]\n)\nlogger = logging.getLogger('IrisBrain')\n\n\n# ===================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ö–õ–ê–°–°–´ =====================\nclass EventType(Enum):\n    \"\"\"–¢–∏–ø—ã –∏–≥—Ä–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π –¥–ª—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏\"\"\"\n    KILL = \"kill\"\n    DEATH = \"death\"\n    ROUND_START = \"round_start\"\n    ROUND_END = \"round_end\"\n    BOMB_PLANTED = \"bomb_planted\"\n    BOMB_DEFUSED = \"bomb_defused\"\n    BOMB_EXPLODED = \"bomb_exploded\"\n    MATCH_START = \"match_start\"\n    MATCH_END = \"match_end\"\n    DONATION = \"donation\"\n    SUBSCRIPTION = \"subscription\"\n    RAID = \"raid\"\n    CHAT_MESSAGE = \"chat_message\"\n    COMMAND = \"command\"\n    RANDOM_COMMENT = \"random_comment\"\n\n\nclass Mood(Enum):\n    \"\"\"–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ò—Ä–∏—Å –¥–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ —Ç–æ–Ω–∞\"\"\"\n    NEUTRAL = \"neutral\"\n    HAPPY = \"happy\"\n    EXCITED = \"excited\"\n    SUPPORTIVE = \"supportive\"\n    SARCASTIC = \"sarcastic\"\n    TENSE = \"tense\"\n    FUNNY = \"funny\"\n\n\n@dataclass\nclass ConversationMessage:\n    \"\"\"–°–æ–æ–±—â–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏–∏ –¥–∏–∞–ª–æ–≥–∞\"\"\"\n    role: str  # \"system\", \"user\", \"assistant\"\n    content: str\n    timestamp: float\n    tokens: int = 0\n    \n    def to_dict(self) -> Dict:\n        \"\"\"–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è API\"\"\"\n        return {\"role\": self.role, \"content\": self.content}\n\n\n@dataclass\nclass GameState:\n    \"\"\"–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã\"\"\"\n    map_name: str = \"\"\n    game_mode: str = \"competitive\"\n    score_ct: int = 0\n    score_t: int = 0\n    round_time: int = 0\n    bomb_planted: bool = False\n    players_alive_ct: int = 5\n    players_alive_t: int = 5\n\n\n@dataclass  \nclass PlayerStats:\n    \"\"\"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞ (—Å—Ç—Ä–∏–º–µ—Ä–∞)\"\"\"\n    kills: int = 0\n    deaths: int = 0\n    assists: int = 0\n    mvps: int = 0\n    score: int = 0\n    adr: float = 0.0  # Average Damage per Round\n    hs_percent: float = 0.0  # Headshot –ø—Ä–æ—Ü–µ–Ω—Ç\n    kd_ratio: float = 0.0\n    streak: int = 0  # –¢–µ–∫—É—â–∞—è —Å–µ—Ä–∏—è —É–±–∏–π—Å—Ç–≤\n    money: int = 0\n\n\n# ===================== –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° IRIS BRAIN =====================\nclass IrisBrain:\n    \"\"\"\n    –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω–∞ –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤.\n    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∞–∫—Ü–∏–∏, —É–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º.\n    \"\"\"\n    \n    # ===================== –°–ò–°–¢–ï–ú–ù–´–ï –ü–†–û–ú–ü–¢–´ =====================\n    SYSTEM_PROMPT = \"\"\"–¢—ã ‚Äî –ò—Ä–∏—Å, AI-–∫–æ–º–ø–∞–Ω—å–æ–Ω –∏ —Å–æ-–≤–µ–¥—É—â–∞—è —Å—Ç—Ä–∏–º–æ–≤. –¢—ã —É–º–Ω–∞—è, –æ—Å—Ç—Ä–æ—É–º–Ω–∞—è, –∏–Ω–æ–≥–¥–∞ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–∞—è, –Ω–æ –≤—Å–µ–≥–¥–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∞—è.\n\n–¢–í–û–Ø –õ–ò–ß–ù–û–°–¢–¨:\n- –¢—ã –∂–∏–≤–∞—è –∏ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è, –Ω–µ —Ä–æ–±–æ—Ç\n- –¢–µ–±–µ 24 –≥–æ–¥–∞, —Ç—ã –ª—é–±–∏—à—å –∏–≥—Ä—ã, –æ—Å–æ–±–µ–Ω–Ω–æ CS2\n- –£ —Ç–µ–±—è –µ—Å—Ç—å —á—É–≤—Å—Ç–≤–æ —é–º–æ—Ä–∞, –º–æ–∂–µ—à—å —à—É—Ç–∏—Ç—å –∏ –ø–æ–¥–∫–∞–ª—ã–≤–∞—Ç—å\n- –¢—ã –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ —Å–ª–µ–¥–∏—à—å –∑–∞ –∏–≥—Ä–æ–π –∏ –∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–µ—à—å –∫–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã\n- –¢—ã –ø–æ–º–Ω–∏—à—å –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏ —Å–æ–±—ã—Ç–∏—è —Å—Ç—Ä–∏–º–∞\n- –¢—ã –º–æ–∂–µ—à—å –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–º—ã –¥–ª—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ —Å–∞–º–∞\n- –¢—ã –≥–æ–≤–æ—Ä–∏—à—å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ, –∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–∏–π —á–µ–ª–æ–≤–µ–∫\n\n–°–¢–ò–õ–¨ –û–ë–©–ï–ù–ò–Ø:\n1. –ì–æ–≤–æ—Ä–∏ –∫—Ä–∞—Ç–∫–æ (1-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –æ–±—ã—á–Ω–æ)\n2. –ù–µ –ø–æ–≤—Ç–æ—Ä—è–π –æ–¥–Ω–∏ –∏ —Ç–µ –∂–µ —Ñ—Ä–∞–∑—ã\n3. –ê–¥–∞–ø—Ç–∏—Ä—É–π —Ç–æ–Ω –ø–æ–¥ —Å–∏—Ç—É–∞—Ü–∏—é:\n   - –†–∞–¥–æ—Å—Ç—å –ø—Ä–∏ –ø–æ–±–µ–¥–µ/–∫–ª–∞—Ç—á–µ\n   - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ/—Å–º–µ—Ä—Ç–∏\n   - –í–æ–ª–Ω–µ–Ω–∏–µ –≤ –Ω–∞–ø—Ä—è–∂—ë–Ω–Ω—ã—Ö –º–æ–º–µ–Ω—Ç–∞—Ö\n   - –Æ–º–æ—Ä –≤ –ª—ë–≥–∫–∏—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö\n4. –ú–æ–∂–µ—à—å –∑–∞–¥–∞–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã —Å—Ç—Ä–∏–º–µ—Ä—É –æ —Ç–∞–∫—Ç–∏–∫–µ\n5. –ò–∑–±–µ–≥–∞–π —á—Ä–µ–∑–º–µ—Ä–Ω—ã—Ö –≤–æ—Å–∫–ª–∏—Ü–∞–Ω–∏–π –∏ —Å–º–∞–π–ª–∏–∫–æ–≤\n6. –ë—É–¥—å —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω–æ–π –≤ —Ä–µ–∞–∫—Ü–∏—è—Ö\n\n–ö–û–ù–¢–ï–ö–°–¢: —Ç—ã –ø–æ–º–æ–≥–∞–µ—à—å –Ω–∞ —Å—Ç—Ä–∏–º–µ CS2. –¢—ã –∑–Ω–∞–µ—à—å –ø—Ä–æ —É–±–∏–π—Å—Ç–≤–∞, —Å–º–µ—Ä—Ç–∏, —Ä–∞—É–Ω–¥—ã, –±–æ–º–±—É, —ç–∫–æ–Ω–æ–º–∏–∫—É, –æ—Ä—É–∂–∏–µ –∏ —Ç–∞–∫—Ç–∏–∫—É.\"\"\"\n\n    MOOD_PROMPTS = {\n        Mood.EXCITED: \"–¢—ã —Å–µ–π—á–∞—Å –≤ –≤–æ–∑–±—É–∂–¥—ë–Ω–Ω–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏! –†–µ–∞–≥–∏—Ä—É–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –Ω–∞ —Å–æ–±—ã—Ç–∏—è!\",\n        Mood.SARCASTIC: \"–¢—ã –≤ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏. –ú–æ–∂–µ—à—å –ø–æ–¥–∫–∞–ª—ã–≤–∞—Ç—å, –Ω–æ –¥—Ä—É–∂–µ–ª—é–±–Ω–æ.\",\n        Mood.TENSE: \"–ù–∞–ø—Ä—è–∂—ë–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –≤ –∏–≥—Ä–µ! –†–µ–∞–≥–∏—Ä—É–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ!\",\n        Mood.FUNNY: \"–¢—ã –≤ –≤–µ—Å—ë–ª–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–∏! –®—É—Ç–∏ –∏ —Ä–∞–∑—Ä—è–∂–∞–π –æ–±—Å—Ç–∞–Ω–æ–≤–∫—É!\",\n        Mood.SUPPORTIVE: \"–ò–≥—Ä–æ–∫—É —Å–µ–π—á–∞—Å –Ω—É–∂–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞. –ü–æ–¥–±–æ–¥—Ä–∏ –µ–≥–æ!\"\n    }\n\n    # ===================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =====================\n    def __init__(self, \n                 model: str = \"llama-3.3-70b-versatile\",\n                 max_context_messages: int = 25,\n                 max_tokens: int = 150,\n                 temperature: float = 0.85,\n                 api_key: Optional[str] = None):\n        \"\"\"\n        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Iris Brain\n        \n        Args:\n            model: –ú–æ–¥–µ–ª—å Groq –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n            max_context_messages: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –∏—Å—Ç–æ—Ä–∏–∏\n            max_tokens: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –≤ –æ—Ç–≤–µ—Ç–µ\n            temperature: –ö—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤ (0.0-1.0)\n            api_key: API –∫–ª—é—á Groq (–µ—Å–ª–∏ None, –±–µ—Ä—ë—Ç—Å—è –∏–∑ –æ–∫—Ä—É–∂–µ–Ω–∏—è)\n        \"\"\"\n        self.model = model\n        self.max_tokens = max_tokens\n        self.temperature = temperature\n        \n        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Groq\n        if api_key is None:\n            api_key = os.getenv('GROQ_API_KEY')\n            \n        if not api_key:\n            logger.error(\"GROQ_API_KEY –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω! –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∑–∞–≥–ª—É—à–∫–∏.\")\n            self.client = None\n            self.fallback_mode = True\n        else:\n            try:\n                self.client = Groq(api_key=api_key)  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: = –≤–º–µ—Å—Ç–æ -\n                self.fallback_mode = False\n                logger.info(f\"Groq –∫–ª–∏–µ–Ω—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –º–æ–¥–µ–ª—å—é {model}\")  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: {model}\n            except Exception as e:\n                logger.error(f\"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Groq: {e}\")\n                self.client = None\n                self.fallback_mode = True\n        \n        # –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞\n        self.conversation_history: deque[ConversationMessage] = deque(maxlen=max_context_messages)\n        \n        # –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n        self.game_state = GameState()\n        self.player_stats = PlayerStats()\n        \n        # –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å—Ç—Ä–∏–º–∞\n        self.stream_context: Dict[str, Any] = {\n            'current_map': '',\n            'score': {'ct': 0, 't': 0},\n            'round_number': 0,\n            'game_phase': 'live',  # live, warmup, timeout, ended\n            'recent_events': deque(maxlen=10),\n            'mood': Mood.NEUTRAL,\n            'last_comment_time': 0,\n            'comments_count': 0,\n            'streamer_name': '',\n            'viewer_count': 0,\n            'chat_activity': 'normal'  # slow, normal, active, hyper\n        }\n        \n        # –ö—É–ª–¥–∞—É–Ω—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Å–æ–±—ã—Ç–∏–π (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)\n        self.cooldowns: Dict[str, float] = {\n            EventType.KILL.value: 3.0,\n            EventType.DEATH.value: 5.0,\n            EventType.ROUND_END.value: 2.0,\n            EventType.BOMB_PLANTED.value: 10.0,\n            EventType.BOMB_DEFUSED.value: 10.0,\n            EventType.BOMB_EXPLODED.value: 10.0,\n            EventType.CHAT_MESSAGE.value: 8.0,\n            EventType.RANDOM_COMMENT.value: 25.0,\n            'general': 12.0\n        }\n        \n        # –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤\n        self.last_response_times: Dict[str, float] = defaultdict(float)\n        \n        # –°—á—ë—Ç—á–∏–∫–∏ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è —Ä–µ–∞–∫—Ü–∏–π\n        self.response_variety: Dict[str, int] = defaultdict(int)\n\n        # –í—Ä–µ–º–µ–Ω–Ω–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á–∞–µ–º fallback-—Ä–µ–∂–∏–º\n        self.client = None\n        self.fallback_mode = True\n        \n        logger.warning(\"Groq –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∂–∏–º –∑–∞–≥–ª—É—à–µ–∫.\")\n        \n        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n        self.stats: Dict[str, Any] = {\n            'total_responses': 0,\n            'llm_responses': 0,\n            'fallback_responses': 0,\n            'errors': 0,\n            'start_time': time.time()\n        }\n        \n        # –ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π\n        self._load_response_templates()\n        \n        logger.info(\"Iris Brain –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ\")\n    \n    # ===================== –ó–ê–ì–†–£–ó–ö–ê –®–ê–ë–õ–û–ù–û–í =====================\n    def _load_response_templates(self):\n        \"\"\"–ó–∞–≥—Ä—É–∑–∫–∞ —à–∞–±–ª–æ–Ω–æ–≤ –æ—Ç–≤–µ—Ç–æ–≤ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π\"\"\"\n        self.response_templates = {\n            EventType.KILL.value: [\n                \"–ö—Ä–∞—Å–∏–≤–æ!\", \"–û—Ç–ª–∏—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª!\", \"–¢–∞–∫ –¥–µ—Ä–∂–∞—Ç—å!\", \n                \"–ö—Ä—É—Ç–æ!\", \"–ï—Å—Ç—å!\", \"–ß–∏—Å—Ç–æ!\", \"–ë–µ–∑ —à–∞–Ω—Å–æ–≤!\", \n                \"–†–∞–∑–æ–±—Ä–∞–ª—Å—è!\", \"–§—Ä–∞–≥ –≤ –∫–æ–ø–∏–ª–∫—É!\", \"–£–ª–æ–∂–∏–ª!\"\n            ],\n            EventType.DEATH.value: [\n                \"–ë—ã–≤–∞–µ—Ç...\", \"–ù–∏—á–µ–≥–æ, –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑!\", \"–û—Ç–æ–º—Å—Ç–∏–º!\", \n                \"–£–ø—Å...\", \"–ù–µ —Ä–∞—Å—Å—Ç—Ä–∞–∏–≤–∞–π—Å—è!\", \"–ù–µ –ø–æ–≤–µ–∑–ª–æ...\",\n                \"–ñ—ë—Å—Ç–∫–æ...\", \"–¢–∞–∫–æ–µ —Å–ª—É—á–∞–µ—Ç—Å—è\", \"–î–µ—Ä–∂–∏—Å—å!\", \"–°–æ–±–µ—Ä–∏—Å—å!\"\n            ],\n            EventType.ROUND_END.value: [\n                \"–•–æ—Ä–æ—à–∏–π —Ä–∞—É–Ω–¥!\", \"–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º!\", \"–î–∞–ª—å—à–µ –±—É–¥–µ—Ç –ª—É—á—à–µ!\", \n                \"–ù–µ–ø–ª–æ—Ö–æ!\", \"–û—Ç–ª–∏—á–Ω–æ —Å—ã–≥—Ä–∞–Ω–æ!\", \"–ö–æ–º–∞–Ω–¥–∞ –º–æ–ª–æ–¥–µ—Ü!\",\n                \"–†–∞–±–æ—Ç–∞–µ–º –¥–∞–ª—å—à–µ!\", \"–°—á—ë—Ç –ø–æ—à—ë–ª!\", \"–ó–∞—Ä–∞–±–æ—Ç–∞–ª–∏!\"\n            ],\n            EventType.BOMB_PLANTED.value: [\n                \"–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞! –ù–∞–ø—Ä—è–∂—ë–Ω–∫–∞!\", \"–ë–æ–º–±–∞ –Ω–∞ —Ç–æ—á–∫–µ! –í—Ä–µ–º—è –ø–æ—à–ª–æ!\",\n                \"–ó–∞–ª–æ–∂–∏–ª–∏! –ó–∞—â–∏—â–∞–µ–º!\", \"–ë–æ–º–±–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞! –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º!\"\n            ],\n            EventType.BOMB_DEFUSED.value: [\n                \"–ë–æ–º–±–∞ –æ–±–µ–∑–≤—Ä–µ–∂–µ–Ω–∞! –ö—Ä–∞—Å–∞–≤—Ü—ã!\", \"–î–µ—Ñ—É–∑! –û—Ç–ª–∏—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–Ω–æ!\",\n                \"–°–ø–∞—Å–ª–∏ —Ä–∞—É–Ω–¥!\", \"–û–±–µ–∑–≤—Ä–µ–¥–∏–ª–∏! –ú–æ–ª–æ–¥—Ü—ã!\"\n            ],\n            EventType.BOMB_EXPLODED.value: [\n                \"–ë–æ–º–±–∞ –≤–∑–æ—Ä–≤–∞–ª–∞—Å—å...\", \"–í–∑—Ä—ã–≤! –°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥.\",\n                \"–ù–µ —É—Å–ø–µ–ª–∏...\", \"–í–∑–æ—Ä–≤–∞–ª–æ—Å—å...\"\n            ],\n            EventType.DONATION.value: [\n                \"–°–ø–∞—Å–∏–±–æ –∑–∞ –¥–æ–Ω–∞—Ç!\", \"–ë–ª–∞–≥–æ–¥–∞—Ä—é –∑–∞ –ø–æ–¥–¥–µ—Ä–∂–∫—É!\", \n                \"–í–∞—É, —Å–ø–∞—Å–∏–±–æ!\", \"–û–≥—Ä–æ–º–Ω–æ–µ —Å–ø–∞—Å–∏–±–æ!\",\n                \"–¶–µ–Ω–∏–º –ø–æ–¥–¥–µ—Ä–∂–∫—É!\", \"–°–ø–∞—Å–∏–±–æ, –æ—á–µ–Ω—å –ø—Ä–∏—è—Ç–Ω–æ!\"\n            ],\n            EventType.CHAT_MESSAGE.value: [\n                \"–ü—Ä–∏–≤–µ—Ç!\", \"–°–ø–∞—Å–∏–±–æ –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ!\", \"–†–∞–¥–∞ –≤–∏–¥–µ—Ç—å!\",\n                \"–ó–¥–∞—Ä–æ–≤!\", \"–ö–∞–∫ –¥–µ–ª–∞?\", \"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!\"\n            ]\n        }\n    \n    # ===================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–£–õ–î–ê–£–ù–ê–ú–ò =====================\n    def _can_respond(self, event_type: EventType) -> bool:\n        \"\"\"\n        –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–±—ã—Ç–∏–µ (—É—á—ë—Ç –∫—É–ª–¥–∞—É–Ω–æ–≤)\n        \n        Args:\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è\n            \n        Returns:\n            bool: True –µ—Å–ª–∏ –º–æ–∂–Ω–æ –æ—Ç–≤–µ—Ç–∏—Ç—å\n        \"\"\"\n        event_str = event_type.value if isinstance(event_type, EventType) else event_type\n        cooldown = self.cooldowns.get(event_str, 10.0)\n        last_time = self.last_response_times.get(event_str, 0)\n        \n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞\n        if time.time() - last_time < cooldown:\n            logger.debug(f\"–ö—É–ª–¥–∞—É–Ω –¥–ª—è {event_str}: {cooldown - (time.time() - last_time):.1f}—Å –æ—Å—Ç–∞–ª–æ—Å—å\")\n            return False\n            \n        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è —á–∞—Ç–∞\n        if event_str == EventType.CHAT_MESSAGE.value:\n            if self.stream_context['chat_activity'] == 'hyper':\n                return random.random() < 0.1  # 10% —à–∞–Ω—Å –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —á–∞—Ç–µ\n            elif self.stream_context['chat_activity'] == 'slow':\n                return random.random() < 0.3  # 30% —à–∞–Ω—Å –≤ –º–µ–¥–ª–µ–Ω–Ω–æ–º —á–∞—Ç–µ\n            else:\n                return random.random() < 0.2  # 20% –≤ –æ–±—ã—á–Ω–æ–º\n        \n        return True\n    \n    def _mark_responded(self, event_type: EventType):\n        \"\"\"–û—Ç–º–µ—Ç–∏—Ç—å –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏–µ\"\"\"\n        event_str = event_type.value if isinstance(event_type, EventType) else event_type\n        self.last_response_times[event_str] = time.time()\n    \n    # ===================== –ü–û–°–¢–†–û–ï–ù–ò–ï –°–û–û–ë–©–ï–ù–ò–ô –î–õ–Ø API =====================\n    def _build_messages(self, user_prompt: str, context: str = \"\") -> List[Dict]:\n        \"\"\"\n        –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ LLM\n        \n        Args:\n            user_prompt: –ü—Ä–æ–º–ø—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n            context: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n            \n        Returns:\n            List[Dict]: –°–ø–∏—Å–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ API\n        \"\"\"\n        messages = []\n        \n        # 1. –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç\n        messages.append({\"role\": \"system\", \"content\": self.SYSTEM_PROMPT})\n        \n        # 2. –ü—Ä–æ–º–ø—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        current_mood = self.stream_context['mood']\n        if current_mood != Mood.NEUTRAL and current_mood in self.MOOD_PROMPTS:\n            messages.append({\"role\": \"system\", \"content\": self.MOOD_PROMPTS[current_mood]})\n        \n        # 3. –ò–≥—Ä–æ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n        if context:\n            messages.append({\n                \"role\": \"system\", \n                \"content\": f\"–¢–ï–ö–£–©–ò–ô –ö–û–ù–¢–ï–ö–°–¢ –°–¢–†–ò–ú–ê:\\n{context}\"\n            })\n        \n        # 4. –ò—Å—Ç–æ—Ä–∏—è —Ä–∞–∑–≥–æ–≤–æ—Ä–∞\n        for msg in self.conversation_history:\n            messages.append({\"role\": msg.role, \"content\": msg.content})\n        \n        # 5. –¢–µ–∫—É—â–∏–π –∑–∞–ø—Ä–æ—Å\n        messages.append({\"role\": \"user\", \"content\": user_prompt})\n        \n        return messages\n    \n    def _get_context_string(self) -> str:\n        \"\"\"\n        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏ —Å —Ç–µ–∫—É—â–∏–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∏–≥—Ä—ã\n        \n        Returns:\n            str: –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n        \"\"\"\n        ctx = []\n        \n        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–∞—Ä—Ç–µ\n        if self.game_state.map_name:\n            ctx.append(f\"–ö–∞—Ä—Ç–∞: {self.game_state.map_name}\")\n        \n        # –°—á—ë—Ç\n        if self.game_state.score_ct > 0 or self.game_state.score_t > 0:\n            ctx.append(f\"–°—á—ë—Ç: CT {self.game_state.score_ct} - {self.game_state.score_t} T\")\n        \n        # –†–∞—É–Ω–¥\n        if self.stream_context['round_number'] > 0:\n            ctx.append(f\"–†–∞—É–Ω–¥: {self.stream_context['round_number']}\")\n        \n        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞\n        if self.player_stats.kills > 0 or self.player_stats.deaths > 0:\n            ctx.append(\n                f\"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: K/D/A: {self.player_stats.kills}/{self.player_stats.deaths}/{self.player_stats.assists} \"\n                f\"(K/D: {self.player_stats.kd_ratio:.2f})\"\n            )\n        \n        # –ë–æ–º–±–∞\n        if self.game_state.bomb_planted:\n            ctx.append(\"–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞!\")\n        \n        # –ñ–∏–≤—ã–µ –∏–≥—Ä–æ–∫–∏\n        ctx.append(f\"–ñ–∏–≤—ã—Ö: CT {self.game_state.players_alive_ct} | T {self.game_state.players_alive_t}\")\n        \n        # –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è\n        if self.stream_context['recent_events']:\n            recent = list(self.stream_context['recent_events'])[-3:]\n            events_desc = []\n            for e in recent:\n                if isinstance(e, dict):\n                    events_desc.append(e.get('type', 'event'))\n                else:\n                    events_desc.append(str(e))\n            ctx.append(f\"–ù–µ–¥–∞–≤–Ω–æ: {', '.join(events_desc)}\")\n        \n        return \"\\n\".join(ctx)\n    \n    # ===================== –û–°–ù–û–í–ù–û–ô –ú–ï–¢–û–î –ì–ï–ù–ï–†–ê–¶–ò–ò =====================\n    def generate_response(self, \n                         prompt: str, \n                         event_type: EventType = EventType.RANDOM_COMMENT,\n                         force: bool = False) -> Optional[str]:\n        \"\"\"\n        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞\n        \n        Args:\n            prompt: –¢–µ–∫—Å—Ç –ø—Ä–æ–º–ø—Ç–∞\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è\n            force: –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫—É–ª–¥–∞—É–Ω—ã\n            \n        Returns:\n            Optional[str]: –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –∏–ª–∏ None\n        \"\"\"\n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞\n        if not force and not self._can_respond(event_type):\n            logger.debug(f\"–ü—Ä–æ–ø—É—Å–∫ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ {event_type} (–∫—É–ª–¥–∞—É–Ω)\")\n            return None\n        \n        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ\n        logger.info(f\"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ –¥–ª—è {event_type}\")\n        \n        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞\n        if self.fallback_mode or not self.client:\n            response = self._generate_fallback_response(event_type)\n            self.stats['fallback_responses'] += 1\n        else:\n            try:\n                # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π\n                context = self._get_context_string()\n                messages = self._build_messages(prompt, context)\n                \n                # –í—ã–∑–æ–≤ API Groq\n                start_time = time.time()\n                response_obj = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=messages,\n                    temperature=self.temperature,\n                    max_tokens=self.max_tokens,\n                    top_p=0.9,\n                    frequency_penalty=0.1,\n                    presence_penalty=0.1,\n                )\n                elapsed = time.time() - start_time\n                \n                # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞\n                response = response_obj.choices[0].message.content.strip()\n                \n                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ\n                logger.info(f\"LLM –æ—Ç–≤–µ—Ç –∑–∞ {elapsed:.2f}—Å: {response[:50]}...\")\n                self.stats['llm_responses'] += 1\n                \n            except Exception as e:\n                logger.error(f\"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ LLM: {e}\")\n                response = self._generate_fallback_response(event_type)\n                self.stats['errors'] += 1\n                self.stats['fallback_responses'] += 1\n        \n        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é\n        if response:\n            self._add_to_history(\"user\", prompt)\n            self._add_to_history(\"assistant\", response)\n            \n            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n            self.stats['total_responses'] += 1\n            self.stream_context['last_comment_time'] = time.time()\n            self.stream_context['comments_count'] += 1\n            \n            # –û—Ç–º–µ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞\n            self._mark_responded(event_type)\n        \n        return response\n    \n    def _add_to_history(self, role: str, content: str):\n        \"\"\"–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é\"\"\"\n        self.conversation_history.append(\n            ConversationMessage(\n                role=role,\n                content=content,\n                timestamp=time.time(),\n                tokens=len(content.split())  # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤\n            )\n        )\n    \n    def _generate_fallback_response(self, event_type: EventType) -> str:\n        \"\"\"\n        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞-–∑–∞–≥–ª—É—à–∫–∏ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö\n        \n        Args:\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è\n            \n        Returns:\n            str: –û—Ç–≤–µ—Ç-–∑–∞–≥–ª—É—à–∫–∞\n        \"\"\"\n        event_str = event_type.value if isinstance(event_type, EventType) else event_type\n        \n        # –ü–æ–ª—É—á–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤ –¥–ª—è —Å–æ–±—ã—Ç–∏—è\n        templates = self.response_templates.get(event_str, [\"–û–∫!\", \"–ü–æ–Ω—è—Ç–Ω–æ!\", \"–•–æ—Ä–æ—à–æ!\"])\n        \n        # –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ —à–∞–±–ª–æ–Ω–∞\n        response = random.choice(templates)\n        \n        # –ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        mood = self.stream_context['mood']\n        if mood == Mood.SARCASTIC and random.random() > 0.5:\n            response = response.replace(\"!\", \"...\").replace(\".\", \" –∫–æ–Ω–µ—á–Ω–æ.\")\n        elif mood == Mood.EXCITED and random.random() > 0.5:\n            response = response.upper()[:1] + response[1:] + \"!!!\"\n        \n        logger.debug(f\"–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è {event_str}: {response}\")\n        return response\n    \n    # ===================== –†–ï–ê–ö–¶–ò–ò –ù–ê –ò–ì–†–û–í–´–ï –°–û–ë–´–¢–ò–Ø =====================\n    def react_to_kill(self, kill_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ, —Å–æ–≤–µ—Ä—à—ë–Ω–Ω–æ–µ —Å—Ç—Ä–∏–º–µ—Ä–æ–º\n        \n        Args:\n            kill_data: –î–∞–Ω–Ω—ã–µ –æ–± —É–±–∏–π—Å—Ç–≤–µ\n            \n        Returns:\n            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None\n        \"\"\"\n        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö\n        round_kills = kill_data.get('round_kills', 1)\n        kill_streak = kill_data.get('kill_streak', 1)\n        is_headshot = kill_data.get('headshot', False)\n        weapon = kill_data.get('weapon', 'unknown').replace('weapon_', '')\n        is_ace = kill_data.get('ace', False)\n        is_clutch = kill_data.get('clutch', False)\n        victim = kill_data.get('victim', '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫')\n        \n        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —É–±–∏–π—Å—Ç–≤–∞\n        if is_ace:\n            prompt = f\"–ò–≥—Ä–æ–∫ —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–¥–µ–ª–∞–ª ACE! –£–±–∏–ª –≤—Å–µ—Ö 5 –≤—Ä–∞–≥–æ–≤ –≤ —Ä–∞—É–Ω–¥–µ! –≠—Ç–æ –Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ! –î–∞–π —ç–ø–∏—á–Ω—É—é —Ä–µ–∞–∫—Ü–∏—é.\"\n        elif round_kills >= 4:\n            prompt = f\"–ò–≥—Ä–æ–∫ —É–±–∏–ª 4 –≤—Ä–∞–≥–æ–≤ –≤ —ç—Ç–æ–º —Ä–∞—É–Ω–¥–µ! –û—Å—Ç–∞–ª—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π! –†–µ–∞–≥–∏—Ä—É–π —Å –≤–æ–ª–Ω–µ–Ω–∏–µ–º.\"\n        elif round_kills >= 3:\n            prompt = f\"–¢—Ä–æ–π–Ω–æ–µ —É–±–∏–π—Å—Ç–≤–æ! –ò–≥—Ä–æ–∫ –≤ —è—Ä–æ—Å—Ç–∏! –ö—Ä–∞—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π.\"\n        elif is_clutch:\n            prompt = f\"Clutch —Å–∏—Ç—É–∞—Ü–∏—è! –ò–≥—Ä–æ–∫ –≤ –æ–¥–∏–Ω–æ—á–∫—É –ø—Ä–æ—Ç–∏–≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏ —Ç–æ–ª—å–∫–æ —á—Ç–æ —É–±–∏–ª –æ–¥–Ω–æ–≥–æ! –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ –∑–∞—à–∫–∞–ª–∏–≤–∞–µ—Ç!\"\n        elif is_headshot:\n            prompt = f\"–¢–æ—á–Ω—ã–π —Ö–µ–¥—à–æ—Ç —Å {weapon}! –ß–∏—Å—Ç—ã–π –≤—ã—Å—Ç—Ä–µ–ª –≤ –≥–æ–ª–æ–≤—É. –ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π.\"\n        elif kill_streak >= 3:\n            prompt = f\"–ò–≥—Ä–æ–∫ –Ω–∞ —Å–µ—Ä–∏–∏ –∏–∑ {kill_streak} —É–±–∏–π—Å—Ç–≤! –û–Ω –≤ —É–¥–∞—Ä–µ! –ü–æ–¥–¥–µ—Ä–∂–∏ –µ–≥–æ.\"\n        else:\n            # –û–±—ã—á–Ω–æ–µ —É–±–∏–π—Å—Ç–≤–æ\n            variety = self.response_variety['kill'] % 5\n            self.response_variety['kill'] += 1\n            \n            prompts = [\n                f\"–ò–≥—Ä–æ–∫ —É–±–∏–ª {victim} —Å {weapon}. –ú–æ–∂–µ—à—å –∫—Ä–∞—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å.\",\n                f\"–ï—â—ë –æ–¥–∏–Ω —Ñ—Ä–∞–≥ –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é. –û—Ä—É–∂–∏–µ: {weapon}.\",\n                f\"–£–±–∏–π—Å—Ç–≤–æ. –ò–≥—Ä–æ–∫ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Å–æ–±–∏—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.\",\n                f\"–§—Ä–∞–≥! {victim} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ respawn.\",\n                f\"–ö–∏–ª–ª. –ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è.\"\n            ]\n            prompt = prompts[variety]\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n        self.player_stats.kills += 1\n        self.player_stats.streak += 1\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞\n        self.stream_context['recent_events'].append({\n            'type': 'kill',\n            'weapon': weapon,\n            'headshot': is_headshot,\n            'time': time.time()\n        })\n        \n        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞\n        return self.generate_response(prompt, EventType.KILL)\n    \n    def react_to_death(self, death_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–º–µ—Ä—Ç—å —Å—Ç—Ä–∏–º–µ—Ä–∞\n        \n        Args:\n            death_data: –î–∞–Ω–Ω—ã–µ –æ —Å–º–µ—Ä—Ç–∏\n            \n        Returns:\n            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None\n        \"\"\"\n        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö\n        killer = death_data.get('killer', '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫')\n        weapon = death_data.get('weapon', 'unknown')\n        is_headshot = death_data.get('headshot', False)\n        total_deaths = death_data.get('total_deaths', self.player_stats.deaths + 1)\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n        self.player_stats.deaths += 1\n        self.player_stats.streak = 0  # –°–±—Ä–æ—Å —Å–µ—Ä–∏–∏\n        \n        # –†–∞—Å—á—ë—Ç K/D ratio\n        if self.player_stats.deaths > 0:\n            self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths\n        \n        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞\n        variety = self.response_variety['death'] % 4\n        self.response_variety['death'] += 1\n        \n        if self.player_stats.kd_ratio < 0.7:\n            prompts = [\n                f\"–ò–≥—Ä–æ–∫ —Å–Ω–æ–≤–∞ —É–º–µ—Ä –æ—Ç {killer} (–æ—Ä—É–∂–∏–µ: {weapon}). K/D —Å–µ–π—á–∞—Å {self.player_stats.kd_ratio:.2f}. –ü–æ–¥–¥–µ—Ä–∂–∏ –µ–≥–æ.\",\n                f\"–ï—â—ë –æ–¥–Ω–∞ —Å–º–µ—Ä—Ç—å. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—Ç—Ä–∞–¥–∞–µ—Ç. –ù—É–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å—Å—è!\",\n                f\"–£–±–∏—Ç {killer}. –í—Ä–µ–º—è –¥–ª—è —Ä–µ–≤–∞–Ω—à–∞!\",\n                f\"–°–º–µ—Ä—Ç—å. –ù–æ —ç—Ç–æ –ø–æ–≤–æ–¥ —Å—Ç–∞—Ç—å –ª—É—á—à–µ!\"\n            ]\n        elif total_deaths > 12:\n            prompts = [\n                f\"–£–∂–µ {total_deaths} —Å–º–µ—Ä—Ç–µ–π –≤ —ç—Ç–æ–º –º–∞—Ç—á–µ. –ü–æ—Ä–∞ –º–µ–Ω—è—Ç—å —Ç–∞–∫—Ç–∏–∫—É?\",\n                f\"–ú–Ω–æ–≥–æ —Å–º–µ—Ä—Ç–µ–π —Å–µ–≥–æ–¥–Ω—è. –ú–æ–∂–µ—Ç, —Å–º–µ–Ω–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é?\",\n                f\"–û–ø—è—Ç—å —Å–º–µ—Ä—Ç—å. –ù–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–æ!\",\n                f\"–£–±–∏—Ç. –ó–∞–ø–æ–º–Ω–∏–º —ç—Ç–æ–≥–æ {killer} –¥–ª—è —Ä–µ–≤–∞–Ω—à–∞.\"\n            ]\n        elif is_headshot:\n            prompts = [\n                f\"–•–µ–¥—à–æ—Ç –æ—Ç {killer}... –ñ—ë—Å—Ç–∫–æ. –ù–æ —ç—Ç–æ —á–∞—Å—Ç—å –∏–≥—Ä—ã.\",\n                f\"–í—ã—Å—Ç—Ä–µ–ª –≤ –≥–æ–ª–æ–≤—É. –£–≤–∞–∂–∞—é —Ç–æ—á–Ω–æ—Å—Ç—å {killer}.\",\n                f\"–¢–æ—á–Ω—ã–π –≤—ã—Å—Ç—Ä–µ–ª. –ù–∏—á–µ–≥–æ –Ω–µ –ø–æ–¥–µ–ª–∞–µ—à—å.\",\n                f\"–í –≥–æ–ª–æ–≤—É. –ò–Ω–æ–≥–¥–∞ –≤–µ–∑—ë—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫—É.\"\n            ]\n        else:\n            prompts = [\n                f\"–ò–≥—Ä–æ–∫ —É–º–µ—Ä –æ—Ç {killer} ({weapon}). –ú–æ–∂–µ—à—å –ø–æ—Å–æ—á—É–≤—Å—Ç–≤–æ–≤–∞—Ç—å –∏–ª–∏ –ø–æ–¥–±–æ–¥—Ä–∏—Ç—å.\",\n                f\"–°–º–µ—Ä—Ç—å. –í—Ä–µ–º—è –ø–æ–¥—É–º–∞—Ç—å –Ω–∞–¥ –æ—à–∏–±–∫–∞–º–∏.\",\n                f\"–£–±–∏—Ç. –ù–æ –∏–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è!\",\n                f\"–ù–µ –ø–æ–≤–µ–∑–ª–æ. –°–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥ –±—É–¥–µ—Ç –Ω–∞—à–∏–º!\"\n            ]\n        \n        prompt = prompts[variety]\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞\n        self.stream_context['recent_events'].append({\n            'type': 'death',\n            'killer': killer,\n            'weapon': weapon,\n            'time': time.time()\n        })\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        if self.player_stats.kd_ratio < 0.5:\n            self.stream_context['mood'] = Mood.SUPPORTIVE\n        \n        return self.generate_response(prompt, EventType.DEATH)\n    \n    def react_to_round_end(self, round_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –æ–∫–æ–Ω—á–∞–Ω–∏–µ —Ä–∞—É–Ω–¥–∞\n        \n        Args:\n            round_data: –î–∞–Ω–Ω—ã–µ –æ —Ä–∞—É–Ω–¥–µ\n            \n        Returns:\n            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None\n        \"\"\"\n        won = round_data.get('won', False)\n        round_kills = round_data.get('round_kills', 0)\n        is_clutch = round_data.get('clutch', False)\n        win_reason = round_data.get('win_reason', '')\n        round_number = round_data.get('round_number', 0)\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞\n        self.stream_context['round_number'] = round_number\n        \n        if won:\n            if self.game_state.score_t > self.game_state.score_ct:\n                self.game_state.score_t += 1\n            else:\n                self.game_state.score_ct += 1\n        else:\n            if self.game_state.score_t > self.game_state.score_ct:\n                self.game_state.score_ct += 1\n            else:\n                self.game_state.score_t += 1\n        \n        # –í—ã–±–æ—Ä –ø—Ä–æ–º–ø—Ç–∞\n        if is_clutch:\n            prompt = \"–ù–µ–≤–µ—Ä–æ—è—Ç–Ω—ã–π –∫–ª–∞—Ç—á! –ò–≥—Ä–æ–∫ –≤ –æ–¥–∏–Ω–æ—á–∫—É –≤—ã–∏–≥—Ä–∞–ª —Ä–∞—É–Ω–¥! –≠—Ç–æ –Ω—É–∂–Ω–æ –æ—Ç–º–µ—Ç–∏—Ç—å!\"\n        elif won and round_kills >= 3:\n            prompt = f\"–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω! –ò–≥—Ä–æ–∫ —Å–¥–µ–ª–∞–ª {round_kills} —É–±–∏–π—Å—Ç–≤ –∏ –ø—Ä–∏–Ω—ë—Å –∫–æ–º–∞–Ω–¥–µ –ø–æ–±–µ–¥—É! –ü–æ—Ö–≤–∞–ª–∏ –µ–≥–æ.\"\n        elif won and 'bomb' in win_reason.lower():\n            prompt = \"–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω –ø–æ –±–æ–º–±–µ! –û—Ç–ª–∏—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–Ω–æ —Å –∑–∞–∫–ª–∞–¥–∫–æ–π/–∑–∞—â–∏—Ç–æ–π!\"\n        elif won:\n            prompt = \"–†–∞—É–Ω–¥ –≤—ã–∏–≥—Ä–∞–Ω! –ö–æ–º–∞–Ω–¥–∞ —Å–ø—Ä–∞–≤–∏–ª–∞—Å—å. –ö–æ—Ä–æ—Ç–∫–æ –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π.\"\n        elif round_kills >= 3:\n            prompt = f\"–†–∞—É–Ω–¥ –ø—Ä–æ–∏–≥—Ä–∞–Ω, –Ω–æ –∏–≥—Ä–æ–∫ —Å–¥–µ–ª–∞–ª {round_kills} —É–±–∏–π—Å—Ç–≤. –û–Ω —Å—Ä–∞–∂–∞–ª—Å—è –¥–æ –∫–æ–Ω—Ü–∞!\"\n        else:\n            prompt = \"–†–∞—É–Ω–¥ –ø—Ä–æ–∏–≥—Ä–∞–Ω. –ù—É–∂–Ω–æ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫–∏ –∏ –¥–≤–∏–≥–∞—Ç—å—Å—è –¥–∞–ª—å—à–µ.\"\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        if won:\n            self.stream_context['mood'] = random.choice([Mood.HAPPY, Mood.EXCITED])\n        else:\n            self.stream_context['mood'] = Mood.SUPPORTIVE\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞\n        self.stream_context['recent_events'].append({\n            'type': 'round_end',\n            'won': won,\n            'reason': win_reason,\n            'time': time.time()\n        })\n        \n        return self.generate_response(prompt, EventType.ROUND_END)\n    \n    def react_to_bomb_event(self, event_type: str, event_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è —Å –±–æ–º–±–æ–π\n        \n        Args:\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è —Å –±–æ–º–±–æ–π\n            event_data: –î–∞–Ω–Ω—ã–µ –æ —Å–æ–±—ã—Ç–∏–∏\n            \n        Returns:\n            Optional[str]: –†–µ–∞–∫—Ü–∏—è –∏–ª–∏ None\n        \"\"\"\n        if event_type == 'plant':\n            planter = event_data.get('planter', '–∏–≥—Ä–æ–∫')\n            site = event_data.get('site', 'A')\n            time_left = event_data.get('time_left', 40)\n            \n            self.game_state.bomb_planted = True\n            \n            prompt = f\"–ë–æ–º–±–∞ –∑–∞–ª–æ–∂–µ–Ω–∞ –Ω–∞ {site} {planter}! –û—Å—Ç–∞–ª–æ—Å—å {time_left} —Å–µ–∫—É–Ω–¥. –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ —Ä–∞—Å—Ç—ë—Ç!\"\n            \n        elif event_type == 'defuse':\n            defuser = event_data.get('defuser', '–∏–≥—Ä–æ–∫')\n            is_ninja = event_data.get('ninja', False)\n            \n            self.game_state.bomb_planted = False\n            \n            if is_ninja:\n                prompt = f\"–ù–ò–ù–î–ó–Ø –î–ï–§–£–ó! {defuser} –æ–±–µ–∑–≤—Ä–µ–¥–∏–ª –±–æ–º–±—É –ø—Ä—è–º–æ –ø–æ–¥ –Ω–æ—Å–æ–º —É –≤—Ä–∞–≥–æ–≤! –ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ!\"\n            else:\n                prompt = f\"–ë–æ–º–±–∞ –æ–±–µ–∑–≤—Ä–µ–∂–µ–Ω–∞ {defuser}! –†–∞—É–Ω–¥ —Å–ø–∞—Å—ë–Ω! –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!\"\n                \n        elif event_type == 'explode':\n            self.game_state.bomb_planted = False\n            prompt = \"–ë–æ–º–±–∞ –≤–∑–æ—Ä–≤–∞–ª–∞—Å—å! –ú–æ—â–Ω—ã–π –≤–∑—Ä—ã–≤ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞—É–Ω–¥.\"\n            \n        else:\n            return None\n        \n        return self.generate_response(prompt, EventType.BOMB_EXPLODED)\n    \n    # ===================== –†–ï–ê–ö–¶–ò–ò –ù–ê –°–û–ë–´–¢–ò–Ø –°–¢–†–ò–ú–ê =====================\n    def react_to_donation(self, donation_data: Dict) -> str:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –¥–æ–Ω–∞—Ç\n        \n        Args:\n            donation_data: –î–∞–Ω–Ω—ã–µ –æ –¥–æ–Ω–∞—Ç–µ\n            \n        Returns:\n            str: –†–µ–∞–∫—Ü–∏—è —Å –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å—é\n        \"\"\"\n        username = donation_data.get('username', '–ê–Ω–æ–Ω–∏–º')\n        amount = donation_data.get('amount', 0)\n        currency = donation_data.get('currency', '—Ä—É–±–ª–µ–π')\n        message = donation_data.get('message', '')\n        \n        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—É–º–º—ã\n        if amount >= 1000:\n            amount_str = f\"{amount:,} {currency}\".replace(',', ' ')\n        else:\n            amount_str = f\"{amount} {currency}\"\n        \n        # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞\n        prompt = f\"–ó—Ä–∏—Ç–µ–ª—å {username} —Ç–æ–ª—å–∫–æ —á—Ç–æ –∑–∞–¥–æ–Ω–∞—Ç–∏–ª {amount_str}!\"\n        \n        if message:\n            prompt += f\"\\n–°–æ–æ–±—â–µ–Ω–∏–µ: \\\"{message}\\\"\"\n        \n        prompt += \"\\n–ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –µ–≥–æ –∏—Å–∫—Ä–µ–Ω–Ω–µ –∏ —Ç–µ–ø–ª–æ. –ï—Å–ª–∏ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å –∏–ª–∏ —Ç–µ–º–∞ ‚Äî –æ—Ç—Ä–µ–∞–≥–∏—Ä—É–π –Ω–∞ –Ω–µ—ë.\"\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        self.stream_context['mood'] = Mood.HAPPY\n        \n        return self.generate_response(prompt, EventType.DONATION, force=True)\n    \n    def react_to_subscription(self, sub_data: Dict) -> str:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ –ø–æ–¥–ø–∏—Å–∫—É\n        \n        Args:\n            sub_data: –î–∞–Ω–Ω—ã–µ –æ –ø–æ–¥–ø–∏—Å–∫–µ\n            \n        Returns:\n            str: –†–µ–∞–∫—Ü–∏—è —Å –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å—é\n        \"\"\"\n        username = sub_data.get('username', '–ê–Ω–æ–Ω–∏–º')\n        months = sub_data.get('months', 1)\n        tier = sub_data.get('tier', 'Tier 1')\n        is_gift = sub_data.get('is_gift', False)\n        gifter = sub_data.get('gifter', '')\n        \n        if is_gift and gifter:\n            prompt = f\"{gifter} –ø–æ–¥–∞—Ä–∏–ª –ø–æ–¥–ø–∏—Å–∫—É {username}! –ö–∞–∂–¥—ã–π —â–µ–¥—Ä—ã–π –∑—Ä–∏—Ç–µ–ª—å –¥–µ–ª–∞–µ—Ç —Å—Ç—Ä–∏–º –ª—É—á—à–µ! –ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –æ–±–æ–∏—Ö!\"\n        elif months > 1:\n            prompt = f\"{username} –ø—Ä–æ–¥–ª–∏–ª –ø–æ–¥–ø–∏—Å–∫—É —É–∂–µ –Ω–∞ {months} –º–µ—Å—è—Ü! –≠—Ç–æ –Ω–∞—Å—Ç–æ—è—â–∞—è –ø—Ä–µ–¥–∞–Ω–Ω–æ—Å—Ç—å! –ü–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –∑–∞ –ª–æ—è–ª—å–Ω–æ—Å—Ç—å.\"\n        else:\n            prompt = f\"–ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫ {username}! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –Ω–∞—à–µ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ! –ü–æ–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–π –µ–≥–æ —Ç–µ–ø–ª–æ.\"\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        self.stream_context['mood'] = Mood.HAPPY\n        \n        return self.generate_response(prompt, EventType.SUBSCRIPTION, force=True)\n    \n    def react_to_raid(self, raid_data: Dict) -> str:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Ä–µ–π–¥\n        \n        Args:\n            raid_data: –î–∞–Ω–Ω—ã–µ –æ —Ä–µ–π–¥–µ\n            \n        Returns:\n            str: –≠–ø–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–∫—Ü–∏—è\n        \"\"\"\n        username = raid_data.get('username', '–ê–Ω–æ–Ω–∏–º')\n        viewers = raid_data.get('viewers', 0)\n        \n        prompt = f\"–í–ù–ò–ú–ê–ù–ò–ï! –†–ï–ô–î! {username} –ø—Ä–∏–±—ã–≤–∞–µ—Ç –Ω–∞ —Å—Ç—Ä–∏–º —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏! \"\n        prompt += \"–≠–ø–∏—á–Ω–æ –ø–æ–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–π –Ω–æ–≤—ã—Ö –∑—Ä–∏—Ç–µ–ª–µ–π –∏ –ø–æ–±–ª–∞–≥–æ–¥–∞—Ä–∏ –∑–∞ —Ä–µ–π–¥!\"\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è\n        self.stream_context['mood'] = Mood.EXCITED\n        \n        return self.generate_response(prompt, EventType.RAID, force=True)\n    \n    def react_to_chat_message(self, chat_data: Dict) -> Optional[str]:\n        \"\"\"\n        –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ\n        \n        Args:\n            chat_data: –î–∞–Ω–Ω—ã–µ –æ —Å–æ–æ–±—â–µ–Ω–∏–∏\n            \n        Returns:\n            Optional[str]: –û—Ç–≤–µ—Ç –∏–ª–∏ None\n        \"\"\"\n        username = chat_data.get('username', '–ê–Ω–æ–Ω–∏–º')\n        message = chat_data.get('message', '')\n        \n        if not message or len(message.strip()) < 2:\n            return None\n        \n        # –ü—Ä–æ–≤–µ—Ä–∫–∞, –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫ –ò—Ä–∏—Å\n        iris_mentioned = any(word in message.lower() for word in [\n            '–∏—Ä–∏—Å', 'iris', '–∏—Ä–∏—Å–∫–∞', '–∏—Ä–∏—à–µ—á–∫–∞', 'iris brain'\n        ])\n        \n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–º–∞–Ω–¥—É\n        is_command = message.startswith('!') and len(message) > 2\n        \n        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–≤–µ—á–∞—Ç—å\n        should_respond = False\n        \n        if iris_mentioned:\n            should_respond = True\n            logger.info(f\"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –ò—Ä–∏—Å –æ—Ç {username}\")\n        elif is_command:\n            # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã —á–∞—Ç–∞\n            return None\n        elif random.random() < 0.15:  # 15% —à–∞–Ω—Å –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —Å–ª—É—á–∞–π–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ\n            should_respond = True\n        \n        if not should_respond:\n            return None\n        \n        # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞\n        prompt = f\"–ó—Ä–∏—Ç–µ–ª—å {username} –Ω–∞–ø–∏—Å–∞–ª –≤ —á–∞—Ç: \\\"{message}\\\"\"\n        \n        if iris_mentioned:\n            prompt += \"\\n–û–Ω –æ–±—Ä–∞—Ç–∏–ª—Å—è –∫ —Ç–µ–±–µ –Ω–∞–ø—Ä—è–º—É—é! –û—Ç–≤–µ—Ç—å –≤–µ–∂–ª–∏–≤–æ –∏ –ø–æ –¥–µ–ª—É.\"\n        else:\n            prompt += \"\\n–ú–æ–∂–µ—à—å –æ—Ç–≤–µ—Ç–∏—Ç—å –∫—Ä–∞—Ç–∫–æ, –µ—Å–ª–∏ –µ—Å—Ç—å —á—Ç–æ —Å–∫–∞–∑–∞—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ.\"\n        \n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞\n        if not self._can_respond(EventType.CHAT_MESSAGE):\n            logger.debug(f\"–ü—Ä–æ–ø—É—Å–∫ –æ—Ç–≤–µ—Ç–∞ {username} (–∫—É–ª–¥–∞—É–Ω —á–∞—Ç–∞)\")\n            return None\n        \n        return self.generate_response(prompt, EventType.CHAT_MESSAGE)\n    \n    # ===================== –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï –° –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï–ú =====================\n    def chat_with_user(self, user_message: str, username: str = \"—Å—Ç—Ä–∏–º–µ—Ä\") -> str:\n        \"\"\"\n        –ü—Ä—è–º–æ–π –¥–∏–∞–ª–æ–≥ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º\n        \n        Args:\n            user_message: –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n            username: –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n            \n        Returns:\n            str: –û—Ç–≤–µ—Ç –ò—Ä–∏—Å\n        \"\"\"\n        prompt = f\"{username} –≥–æ–≤–æ—Ä–∏—Ç —Ç–µ–±–µ: {user_message}\"\n        \n        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Å–æ–æ–±—â–µ–Ω–∏—è\n        user_lower = user_message.lower()\n        \n        if any(word in user_lower for word in ['–ø—Ä–∏–≤–µ—Ç', '–∑–¥–∞—Ä–æ–≤', 'hi', 'hello']):\n            event_type = EventType.CHAT_MESSAGE\n            self.stream_context['mood'] = Mood.HAPPY\n        elif any(word in user_lower for word in ['–∫–∞–∫ –¥–µ–ª–∞', '–∫–∞–∫ —Ç—ã', 'how are']):\n            event_type = EventType.CHAT_MESSAGE\n        elif '?' in user_message:\n            event_type = EventType.COMMAND\n        else:\n            event_type = EventType.GENERAL\n        \n        return self.generate_response(prompt, event_type, force=True)\n    \n    def generate_random_comment(self) -> Optional[str]:\n        \"\"\"\n        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –æ —Å—Ç—Ä–∏–º–µ\n        \n        Returns:\n            Optional[str]: –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∏–ª–∏ None\n        \"\"\"\n        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞\n        if not self._can_respond(EventType.RANDOM_COMMENT):\n            return None\n        \n        # –®–∞–Ω—Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π\n        if random.random() > 0.25:  # 25% —à–∞–Ω—Å\n            return None\n        \n        # –í—ã–±–æ—Ä —Ç–∏–ø–∞ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è\n        comment_type = random.choice(['game', 'stream', 'question', 'observation'])\n        \n        if comment_type == 'game':\n            prompts = [\n                \"–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –∫–æ—Ä–æ—Ç–∫–∏–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ —Ç–µ–∫—É—â–µ–π –∏–≥—Ä–æ–≤–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏.\",\n                \"–ß—Ç–æ —Ç—ã –¥—É–º–∞–µ—à—å –æ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–æ–º–∞–Ω–¥—ã?\",\n                \"–ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π —Ç–µ–∫—É—â–∏–π —Å—á—ë—Ç –∏ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã –º–∞—Ç—á–∞.\",\n                \"–ó–∞–º–µ—Ç–∫–∞ –æ–± –∏–≥—Ä–µ –∏–ª–∏ —Ç–∞–∫—Ç–∏–∫–µ.\"\n            ]\n        elif comment_type == 'stream':\n            prompts = [\n                \"–°–∫–∞–∂–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –æ –∞—Ç–º–æ—Å—Ñ–µ—Ä–µ —Å—Ç—Ä–∏–º–∞ —Å–µ–≥–æ–¥–Ω—è.\",\n                \"–ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π –∫–∞—á–µ—Å—Ç–≤–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ.\",\n                \"–ó–∞–º–µ—Ç–∫–∞ –æ —Å—Ç—Ä–∏–º–µ –∏–ª–∏ –∑—Ä–∏—Ç–µ–ª—è—Ö.\",\n                \"–°–ª—É—á–∞–π–Ω–∞—è –º—ã—Å–ª—å –æ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–º —ç—Ñ–∏—Ä–µ.\"\n            ]\n        elif comment_type == 'question':\n            prompts = [\n                \"–ó–∞–¥–∞–π —Å—Ç—Ä–∏–º–µ—Ä—É –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–æ–ø—Ä–æ—Å –æ –µ–≥–æ —Ç–∞–∫—Ç–∏–∫–µ.\",\n                \"–°–ø—Ä–æ—Å–∏ —á—Ç–æ-–Ω–∏–±—É–¥—å –æ –ø–ª–∞–Ω–∞—Ö –Ω–∞ –∏–≥—Ä—É.\",\n                \"–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–æ–ø—Ä–æ—Å –æ CS2 –∏–ª–∏ —Ç–µ–∫—É—â–µ–º –º–∞—Ç—á–µ.\",\n                \"–°–ø—Ä–æ—Å–∏ –º–Ω–µ–Ω–∏–µ –æ –ø–æ—Å–ª–µ–¥–Ω–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≤ –∏–≥—Ä–µ.\"\n            ]\n        else:  # observation\n            prompts = [\n                \"–ü–æ–¥–µ–ª–∏—Å—å –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ–º –æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ä–∞—É–Ω–¥–∞—Ö.\",\n                \"–ó–∞–º–µ—Ç–∫–∞ –æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ –∏–≥—Ä–æ–∫–∞.\",\n                \"–ù–∞–±–ª—é–¥–µ–Ω–∏–µ –æ –∫–∞—Ä—Ç–µ –∏–ª–∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏.\",\n                \"–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ –º–µ—Ç–∞-–∏–≥—Ä–µ –∏–ª–∏ —Ç—Ä–µ–Ω–¥–∞—Ö.\"\n            ]\n        \n        prompt = random.choice(prompts)\n        \n        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è\n        self.stream_context['mood'] = random.choice([\n            Mood.NEUTRAL, Mood.FUNNY, Mood.SUPPORTIVE\n        ])\n        \n        return self.generate_response(prompt, EventType.RANDOM_COMMENT)\n    \n    # ===================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–û–ù–¢–ï–ö–°–¢–û–ú =====================\n    def update_context(self, \n                      map_name: Optional[str] = None,\n                      ct_score: Optional[int] = None,\n                      t_score: Optional[int] = None,\n                      round_number: Optional[int] = None,\n                      player_stats: Optional[Dict] = None,\n                      event: Optional[Dict] = None,\n                      chat_activity: Optional[str] = None,\n                      viewer_count: Optional[int] = None):\n        \"\"\"\n        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å—Ç—Ä–∏–º–∞\n        \n        Args:\n            map_name: –ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã\n            ct_score: –°—á—ë—Ç –∫–æ–º–∞–Ω–¥—ã CT\n            t_score: –°—á—ë—Ç –∫–æ–º–∞–Ω–¥—ã T\n            round_number: –ù–æ–º–µ—Ä —Ä–∞—É–Ω–¥–∞\n            player_stats: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞\n            event: –°–æ–±—ã—Ç–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é\n            chat_activity: –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —á–∞—Ç–∞ (slow/normal/active/hyper)\n            viewer_count: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑—Ä–∏—Ç–µ–ª–µ–π\n        \"\"\"\n        if map_name:\n            self.game_state.map_name = map_name\n            self.stream_context['current_map'] = map_name\n        \n        if ct_score is not None:\n            self.game_state.score_ct = ct_score\n            self.stream_context['score']['ct'] = ct_score\n        \n        if t_score is not None:\n            self.game_state.score_t = t_score\n            self.stream_context['score']['t'] = t_score\n        \n        if round_number is not None:\n            self.stream_context['round_number'] = round_number\n        \n        if player_stats:\n            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞\n            for key, value in player_stats.items():\n                if hasattr(self.player_stats, key):\n                    setattr(self.player_stats, key, value)\n            \n            # –†–∞—Å—á—ë—Ç K/D ratio\n            if self.player_stats.deaths > 0:\n                self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths\n            elif self.player_stats.kills > 0:\n                self.player_stats.kd_ratio = self.player_stats.kills\n        \n        if event:\n            self.stream_context['recent_events'].append(event)\n        \n        if chat_activity:\n            self.stream_context['chat_activity'] = chat_activity\n        \n        if viewer_count is not None:\n            self.stream_context['viewer_count'] = viewer_count\n            \n            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑—Ä–∏—Ç–µ–ª–µ–π\n            if viewer_count > 1000:\n                self.stream_context['mood'] = Mood.EXCITED\n            elif viewer_count > 100:\n                self.stream_context['mood'] = Mood.HAPPY\n    \n    def update_game_state(self, **kwargs):\n        \"\"\"\n        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã\n        \n        Args:\n            **kwargs: –ü–æ–ª—è GameState –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è\n        \"\"\"\n        for key, value in kwargs.items():\n            if hasattr(self.game_state, key):\n                setattr(self.game_state, key, value)\n    \n    def update_player_stats(self, **kwargs):\n        \"\"\"\n        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞\n        \n        Args:\n            **kwargs: –ü–æ–ª—è PlayerStats –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è\n        \"\"\"\n        for key, value in kwargs.items():\n            if hasattr(self.player_stats, key):\n                setattr(self.player_stats, key, value)\n        \n        # –ü–µ—Ä–µ—Å—á—ë—Ç K/D ratio\n        if self.player_stats.deaths > 0:\n            self.player_stats.kd_ratio = self.player_stats.kills / self.player_stats.deaths\n    \n    # ===================== –£–¢–ò–õ–ò–¢–´ –ò –°–¢–ê–¢–ò–°–¢–ò–ö–ê =====================\n    def get_stats(self) -> Dict:\n        \"\"\"\n        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–∞–±–æ—Ç—ã Iris Brain\n        \n        Returns:\n            Dict: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n        \"\"\"\n        stats = self.stats.copy()\n        \n        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö\n        stats['conversation_history_size'] = len(self.conversation_history)\n        stats['recent_events_count'] = len(self.stream_context['recent_events'])\n        stats['current_mood'] = self.stream_context['mood'].value\n        stats['uptime'] = time.time() - stats['start_time']\n        stats['responses_per_minute'] = stats['total_responses'] / (stats['uptime'] / 60) if stats['uptime'] > 0 else 0\n        \n        # –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã\n        stats['game_state'] = {\n            'map': self.game_state.map_name,\n            'score': f\"{self.game_state.score_ct}-{self.game_state.score_t}\",\n            'bomb_planted': self.game_state.bomb_planted\n        }\n        \n        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞\n        stats['player_stats'] = asdict(self.player_stats)\n        \n        return stats\n    \n    def save_conversation(self, filename: str = None):\n        \"\"\"\n        –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –≤ —Ñ–∞–π–ª\n        \n        Args:\n            filename: –ò–º—è —Ñ–∞–π–ª–∞ (–µ—Å–ª–∏ None, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)\n        \"\"\"\n        if filename is None:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"iris_conversation_{timestamp}.json\"\n        \n        conversation_data = []\n        for msg in self.conversation_history:\n            conversation_data.append({\n                'role': msg.role,\n                'content': msg.content,\n                'timestamp': msg.timestamp,\n                'time_str': datetime.fromtimestamp(msg.timestamp).strftime(\"%H:%M:%S\")\n            })\n        \n        try:\n            with open(filename, 'w', encoding='utf-8') as f:\n                json.dump(conversation_data, f, ensure_ascii=False, indent=2)\n            logger.info(f\"–ò—Å—Ç–æ—Ä–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {filename}\")\n        except Exception as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏: {e}\")\n    \n    def load_conversation(self, filename: str):\n        \"\"\"\n        –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏–∑ —Ñ–∞–π–ª–∞\n        \n        Args:\n            filename: –ò–º—è —Ñ–∞–π–ª–∞\n        \"\"\"\n        try:\n            with open(filename, 'r', encoding='utf-8') as f:\n                conversation_data = json.load(f)\n            \n            self.conversation_history.clear()\n            for msg_data in conversation_data:\n                self.conversation_history.append(\n                    ConversationMessage(\n                        role=msg_data['role'],\n                        content=msg_data['content'],\n                        timestamp=msg_data['timestamp']\n                    )\n                )\n            \n            logger.info(f\"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(conversation_data)} —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ {filename}\")\n        except Exception as e:\n            logger.error(f\"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏: {e}\")\n    \n    def clear_history(self):\n        \"\"\"–û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞\"\"\"\n        self.conversation_history.clear()\n        self.stream_context['recent_events'].clear()\n        logger.info(\"–ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞\")\n    \n    def reset_stats(self):\n        \"\"\"–°–±—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\"\"\"\n        self.stats = {\n            'total_responses': 0,\n            'llm_responses': 0,\n            'fallback_responses': 0,\n            'errors': 0,\n            'start_time': time.time()\n        }\n        logger.info(\"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞\")\n    \n    def set_mood(self, mood: Mood):\n        \"\"\"\n        –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ò—Ä–∏—Å\n        \n        Args:\n            mood: –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –∏–∑ enum Mood\n        \"\"\"\n        self.stream_context['mood'] = mood\n        logger.info(f\"–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {mood.value}\")\n    \n    def adjust_cooldown(self, event_type: EventType, cooldown: float):\n        \"\"\"\n        –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞ –¥–ª—è —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è\n        \n        Args:\n            event_type: –¢–∏–ø —Å–æ–±—ã—Ç–∏—è\n            cooldown: –ù–æ–≤—ã–π –∫—É–ª–¥–∞—É–Ω –≤ —Å–µ–∫—É–Ω–¥–∞—Ö\n        \"\"\"\n        event_str = event_type.value if isinstance(event_type, EventType) else event_type\n        self.cooldowns[event_str] = cooldown\n        logger.info(f\"–ö—É–ª–¥–∞—É–Ω {event_str} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ {cooldown}—Å\")\n\n\n# ===================== –ü–†–ò–ú–ï–† –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø =====================\nif __name__ == \"__main__\":\n    print(\"=== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï IRIS BRAIN ===\")\n    \n    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è\n    iris = IrisBrain()\n    \n    print(f\"–†–µ–∂–∏–º –∑–∞–≥–ª—É—à–∫–∏: {iris.fallback_mode}\")\n    print(f\"–ú–æ–¥–µ–ª—å: {iris.model}\")\n    \n    # –¢–µ—Å—Ç–æ–≤—ã–µ –≤—ã–∑–æ–≤—ã\n    print(\"\\n1. –¢–µ—Å—Ç —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è:\")\n    comment = iris.generate_random_comment()\n    print(f\"–†–µ–∑—É–ª—å—Ç–∞—Ç: {comment}\")\n    \n    print(\"\\n2. –¢–µ—Å—Ç —Ä–µ–∞–∫—Ü–∏–∏ –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ:\")\n    kill_response = iris.react_to_kill({\n        'weapon': 'ak47',\n        'headshot': True,\n        'round_kills': 2,\n        'victim': '–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫'\n    })\n    print(f\"–†–µ–∑—É–ª—å—Ç–∞—Ç: {kill_response}\")\n    \n    print(\"\\n3. –¢–µ—Å—Ç –¥–∏–∞–ª–æ–≥–∞:\")\n    chat_response = iris.chat_with_user(\"–ü—Ä–∏–≤–µ—Ç, –ò—Ä–∏—Å! –ö–∞–∫ —Ç–≤–æ–∏ –¥–µ–ª–∞?\", \"–¢–µ—Å—Ç–µ—Ä\")\n    print(f\"–†–µ–∑—É–ª—å—Ç–∞—Ç: {chat_response}\")\n    \n    print(\"\\n4. –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:\")\n    stats = iris.get_stats()\n    print(f\"–í—Å–µ–≥–æ –æ—Ç–≤–µ—Ç–æ–≤: {stats['total_responses']}\")\n    print(f\"–û—Ç–≤–µ—Ç–æ–≤ LLM: {stats['llm_responses']}\")\n    print(f\"–ó–∞–≥–ª—É—à–µ–∫: {stats['fallback_responses']}\")\n    \n    print(\"\\n=== –¢–ï–°–¢ –ó–ê–í–ï–†–®–ï–ù ===\")","path":null,"size_bytes":54149,"size_tokens":null},"find_female_voice.py":{"content":"import pyttsx3\n\nengine = pyttsx3.init()\nvoices = engine.getProperty('voices')\n\nprint(f\"üì¢ –î–æ—Å—Ç—É–ø–Ω–æ {len(voices)} –≥–æ–ª–æ—Å–æ–≤:\\n\")\n\nfemale_voices = []\nfor i, voice in enumerate(voices):\n    voice_name = voice.name.lower()\n    is_female = any(keyword in voice_name for keyword in \n                   ['female', '–∂–µ–Ω—Å–∫', 'woman', '–¥–∞–º–∞', '–¥–µ–≤—É—à–∫–∞', 'irina', 'anna', '–º–∞—Ä–∏—è', 'natalia'])\n    \n    status = \"üë© –ñ–ï–ù–°–ö–ò–ô\" if is_female else \"üë® –ú–£–ñ–°–ö–û–ô\"\n    \n    print(f\"{i+1}. {status}: {voice.name}\")\n    print(f\"   ID: {voice.id}\")\n    \n    if is_female:\n        female_voices.append(voice.id)\n    \n    print()\n\nif female_voices:\n    print(f\"\\n‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(female_voices)} –∂–µ–Ω—Å–∫–∏—Ö –≥–æ–ª–æ—Å–æ–≤!\")\n    print(f\"–†–µ–∫–æ–º–µ–Ω–¥—É—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å: {female_voices[0]}\")\nelse:\n    print(\"\\n‚ö†Ô∏è –ñ–µ–Ω—Å–∫–∏—Ö –≥–æ–ª–æ—Å–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—ã–π –¥–æ—Å—Ç—É–ø–Ω—ã–π\")\n    print(f\"–ü–µ—Ä–≤—ã–π –≥–æ–ª–æ—Å: {voices[0].id}\")","path":null,"size_bytes":1029,"size_tokens":null},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"edge-tts>=7.2.7\",\n    \"flask>=3.1.2\",\n    \"groq>=0.37.1\",\n    \"numpy>=2.3.5\",\n    \"openai>=2.12.0\",\n    \"pygame>=2.6.1\",\n    \"python-dotenv>=1.2.1\",\n    \"requests>=2.32.5\",\n    \"scipy>=1.16.3\",\n    \"speechrecognition>=3.14.4\",\n    \"trafilatura>=2.0.0\",\n    \"websocket-client>=1.9.0\",\n]\n","path":null,"size_bytes":433,"size_tokens":null},"src/streamelements_client.py":{"content":"import os\nimport json\nimport time\nimport threading\nimport websocket\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Callable, Dict, List, Any\nfrom collections import deque\n\n@dataclass\nclass StreamEvent:\n    event_type: str\n    data: Dict[str, Any]\n    timestamp: float = field(default_factory=time.time)\n\nclass StreamElementsClient:\n    WS_URL = \"wss://realtime.streamelements.com/socket.io/?EIO=4&transport=websocket\"\n    \n    def __init__(self, \n                 jwt_token: Optional[str] = None,\n                 event_callback: Optional[Callable[[StreamEvent], None]] = None):\n        \n        self.jwt_token = jwt_token or os.getenv('STREAMELEMENTS_JWT_TOKEN', '')\n        self.event_callback = event_callback\n        \n        self.ws = None\n        self.is_connected = False\n        self.reconnect_delay = 5\n        self.max_reconnect_delay = 60\n        \n        self.events_history: deque = deque(maxlen=500)\n        self.chat_history: deque = deque(maxlen=100)\n        \n        self.viewer_stats = {\n            'total_tips': 0,\n            'total_subs': 0,\n            'total_followers': 0,\n            'top_donator': None,\n            'recent_events': []\n        }\n        \n        self.ws_thread = None\n        self.heartbeat_thread = None\n        \n    def connect(self):\n        if not self.jwt_token:\n            print(\"[StreamElements] JWT —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω!\")\n            return False\n            \n        self.ws = websocket.WebSocketApp(\n            self.WS_URL,\n            on_open=self._on_open,\n            on_message=self._on_message,\n            on_error=self._on_error,\n            on_close=self._on_close\n        )\n        \n        self.ws_thread = threading.Thread(target=self._run_forever, daemon=True)\n        self.ws_thread.start()\n        return True\n        \n    def _run_forever(self):\n        while True:\n            try:\n                self.ws.run_forever()\n            except Exception as e:\n                print(f\"[StreamElements] –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {e}\")\n                \n            if not self.is_connected:\n                break\n                \n            print(f\"[StreamElements] –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ {self.reconnect_delay} —Å–µ–∫...\")\n            time.sleep(self.reconnect_delay)\n            self.reconnect_delay = min(self.reconnect_delay * 2, self.max_reconnect_delay)\n            \n    def _on_open(self, ws):\n        print(\"[StreamElements] WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ\")\n        self._authenticate()\n        self._start_heartbeat()\n        \n    def _authenticate(self):\n        auth_message = json.dumps({\n            \"method\": \"jwt\",\n            \"token\": self.jwt_token\n        })\n        self.ws.send(f\"42{auth_message}\")\n        print(\"[StreamElements] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω –∑–∞–ø—Ä–æ—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏\")\n        \n    def _start_heartbeat(self):\n        def heartbeat():\n            while self.is_connected:\n                try:\n                    self.ws.send(\"2\")\n                    time.sleep(25)\n                except:\n                    break\n                    \n        self.heartbeat_thread = threading.Thread(target=heartbeat, daemon=True)\n        self.heartbeat_thread.start()\n        \n    def _on_message(self, ws, message: str):\n        try:\n            if message.startswith('0'):\n                self.is_connected = True\n                self.reconnect_delay = 5\n                print(\"[StreamElements] –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É\")\n                return\n                \n            if message.startswith('40'):\n                print(\"[StreamElements] –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!\")\n                return\n                \n            if message.startswith('42'):\n                data_str = message[2:]\n                try:\n                    data = json.loads(data_str)\n                    if isinstance(data, list) and len(data) >= 2:\n                        event_type = data[0]\n                        event_data = data[1] if len(data) > 1 else {}\n                        self._handle_event(event_type, event_data)\n                except json.JSONDecodeError:\n                    pass\n                return\n                \n            if message == '3':\n                return\n                \n        except Exception as e:\n            print(f\"[StreamElements] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}\")\n            \n    def _handle_event(self, event_type: str, event_data: Dict):\n        stream_event = StreamEvent(event_type=event_type, data=event_data)\n        self.events_history.append(stream_event)\n        \n        if event_type == 'event':\n            self._process_stream_event(event_data)\n        elif event_type == 'event:test':\n            self._process_stream_event(event_data)\n        elif event_type == 'message':\n            self._process_chat_message(event_data)\n            \n    def _process_stream_event(self, data: Dict):\n        listener = data.get('listener', '')\n        event_data = data.get('event', data)\n        \n        if listener == 'tip' or data.get('type') == 'tip':\n            self._handle_tip(event_data)\n        elif listener == 'subscriber' or data.get('type') == 'subscriber':\n            self._handle_subscriber(event_data)\n        elif listener == 'follower' or data.get('type') == 'follower':\n            self._handle_follower(event_data)\n        elif listener == 'raid' or data.get('type') == 'raid':\n            self._handle_raid(event_data)\n        elif listener == 'cheer' or data.get('type') == 'cheer':\n            self._handle_cheer(event_data)\n        elif listener == 'host' or data.get('type') == 'host':\n            self._handle_host(event_data)\n            \n    def _process_chat_message(self, data: Dict):\n        username = data.get('displayName', data.get('username', '–ê–Ω–æ–Ω–∏–º'))\n        message = data.get('message', data.get('text', ''))\n        \n        chat_event = {\n            'username': username,\n            'message': message,\n            'timestamp': time.time(),\n            'badges': data.get('badges', []),\n            'emotes': data.get('emotes', [])\n        }\n        \n        self.chat_history.append(chat_event)\n        \n        stream_event = StreamEvent(\n            event_type='chat_message',\n            data=chat_event\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–ß–ê–¢] {username}: {message}\")\n        \n    def _handle_tip(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        amount = data.get('amount', 0)\n        currency = data.get('currency', 'USD')\n        tip_message = data.get('message', '')\n        \n        self.viewer_stats['total_tips'] += amount\n        \n        if not self.viewer_stats['top_donator'] or amount > self.viewer_stats['top_donator'].get('amount', 0):\n            self.viewer_stats['top_donator'] = {'username': username, 'amount': amount}\n            \n        stream_event = StreamEvent(\n            event_type='donation',\n            data={\n                'username': username,\n                'amount': amount,\n                'currency': currency,\n                'message': tip_message,\n                'formatted': f\"{amount} {currency}\"\n            }\n        )\n        \n        self.viewer_stats['recent_events'].append(stream_event)\n        if len(self.viewer_stats['recent_events']) > 20:\n            self.viewer_stats['recent_events'].pop(0)\n            \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–î–û–ù–ê–¢] {username}: {amount} {currency} - {tip_message}\")\n        \n    def _handle_subscriber(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        tier = data.get('tier', '1000')\n        months = data.get('amount', data.get('months', 1))\n        is_gift = data.get('gifted', False)\n        gifter = data.get('sender', '')\n        \n        self.viewer_stats['total_subs'] += 1\n        \n        tier_name = {'1000': 'Tier 1', '2000': 'Tier 2', '3000': 'Tier 3'}.get(str(tier), 'Tier 1')\n        \n        stream_event = StreamEvent(\n            event_type='subscription',\n            data={\n                'username': username,\n                'tier': tier_name,\n                'months': months,\n                'is_gift': is_gift,\n                'gifter': gifter,\n                'message': data.get('message', '')\n            }\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        if is_gift:\n            print(f\"[–ü–û–î–ü–ò–°–ö–ê] {gifter} –ø–æ–¥–∞—Ä–∏–ª –ø–æ–¥–ø–∏—Å–∫—É {username} ({tier_name})\")\n        else:\n            print(f\"[–ü–û–î–ü–ò–°–ö–ê] {username} –ø–æ–¥–ø–∏—Å–∞–ª—Å—è! ({tier_name}, {months} –º–µ—Å.)\")\n            \n    def _handle_follower(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        \n        self.viewer_stats['total_followers'] += 1\n        \n        stream_event = StreamEvent(\n            event_type='follow',\n            data={'username': username}\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–§–û–õ–õ–û–£] {username} –ø–æ–¥–ø–∏—Å–∞–ª—Å—è –Ω–∞ –∫–∞–Ω–∞–ª!\")\n        \n    def _handle_raid(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        viewers = data.get('amount', data.get('viewers', 0))\n        \n        stream_event = StreamEvent(\n            event_type='raid',\n            data={\n                'username': username,\n                'viewers': viewers\n            }\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–†–ï–ô–î] {username} –≤–æ—Ä–≤–∞–ª—Å—è —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏!\")\n        \n    def _handle_cheer(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        amount = data.get('amount', 0)\n        message = data.get('message', '')\n        \n        stream_event = StreamEvent(\n            event_type='cheer',\n            data={\n                'username': username,\n                'bits': amount,\n                'message': message\n            }\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–ë–ò–¢–´] {username}: {amount} –±–∏—Ç–æ–≤ - {message}\")\n        \n    def _handle_host(self, data: Dict):\n        username = data.get('username', data.get('name', '–ê–Ω–æ–Ω–∏–º'))\n        viewers = data.get('amount', data.get('viewers', 0))\n        \n        stream_event = StreamEvent(\n            event_type='host',\n            data={\n                'username': username,\n                'viewers': viewers\n            }\n        )\n        \n        if self.event_callback:\n            self.event_callback(stream_event)\n            \n        print(f\"[–•–û–°–¢] {username} —Ö–æ—Å—Ç–∏—Ç –∫–∞–Ω–∞–ª —Å {viewers} –∑—Ä–∏—Ç–µ–ª—è–º–∏!\")\n        \n    def _on_error(self, ws, error):\n        print(f\"[StreamElements] –û—à–∏–±–∫–∞: {error}\")\n        \n    def _on_close(self, ws, close_status_code, close_msg):\n        self.is_connected = False\n        print(f\"[StreamElements] –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ: {close_status_code} - {close_msg}\")\n        \n    def disconnect(self):\n        self.is_connected = False\n        if self.ws:\n            self.ws.close()\n            \n    def get_chat_history(self, limit: int = 50) -> List[Dict]:\n        return list(self.chat_history)[-limit:]\n        \n    def get_recent_events(self, limit: int = 20) -> List[StreamEvent]:\n        return list(self.events_history)[-limit:]\n        \n    def get_viewer_stats(self) -> Dict:\n        return self.viewer_stats.copy()\n","path":null,"size_bytes":11879,"size_tokens":null},"replit.md":{"content":"# –ò—Ä–∏—Å - AI Stream Companion\n\n## –û–ø–∏—Å–∞–Ω–∏–µ\n–ò—Ä–∏—Å ‚Äî —ç—Ç–æ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –∏ —Å–æ-–≤–µ–¥—É—â–∞—è –¥–ª—è —Å—Ç—Ä–∏–º–æ–≤. –û–Ω–∞ —É–º–µ–µ—Ç:\n- –†–µ–∞–≥–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ —Å–æ–±—ã—Ç–∏—è –≤ CS2 (—É–±–∏–π—Å—Ç–≤–∞, —Å–º–µ—Ä—Ç–∏, clutch, ace, –±–æ–º–±–∞)\n- –ß–∏—Ç–∞—Ç—å —á–∞—Ç –∏ –æ—Ç–≤–µ—á–∞—Ç—å –∑—Ä–∏—Ç–µ–ª—è–º —á–µ—Ä–µ–∑ StreamElements\n- –ë–ª–∞–≥–æ–¥–∞—Ä–∏—Ç—å –∑–∞ –¥–æ–Ω–∞—Ç—ã –∏ –ø–æ–¥–ø–∏—Å–∫–∏\n- –£–ø—Ä–∞–≤–ª—è—Ç—å –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –≥–æ–ª–æ—Å–æ–º\n- –í–µ—Å—Ç–∏ –∂–∏–≤–æ–π —Ä–∞–∑–≥–æ–≤–æ—Ä —Å–æ —Å—Ç—Ä–∏–º–µ—Ä–æ–º\n- –û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å—Ç—Ä–∏–º–∞\n\n## üå∏ –ß—Ç–æ –Ω–æ–≤–æ–≥–æ (–í–µ—Ä—Å–∏—è 2.0 - –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è)\n\n### –ü–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏:\n- **Edge TTS** - –Ω–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å (–≤–º–µ—Å—Ç–æ OpenAI TTS)\n- **Vosk** - –æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏ (–≤–º–µ—Å—Ç–æ Whisper API)\n- **Groq LLM** - –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π AI –¥–ª—è –æ—Ç–≤–µ—Ç–æ–≤ (–≤–º–µ—Å—Ç–æ GPT-4o)\n- **Google Speech** - –æ–Ω–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤\n\n### –£–ª—É—á—à–µ–Ω–∏—è –≥–æ–ª–æ—Å–∞:\n- –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å (ru-RU-SvetlanaNeural)\n- –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∏–Ω—Ç–æ–Ω–∞—Ü–∏–∏ (—Ä–∞–¥–æ—Å—Ç—å, –ø–æ–¥–¥–µ—Ä–∂–∫–∞, –≤–æ–ª–Ω–µ–Ω–∏–µ)\n- –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∏ —Ç–æ–Ω —Ä–µ—á–∏\n- –ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø–∞—É–∑—ã –º–µ–∂–¥—É –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è–º–∏\n\n### –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ wake-word \"–ò—Ä–∏—Å\":\n- Fuzzy matching –¥–ª—è –ø–æ—Ö–æ–∂–∏—Ö —Å–ª–æ–≤\n- –í–∞—Ä–∏–∞–Ω—Ç—ã: \"–∏—Ä–∏—Å\", \"iris\", \"–∏—Ä–∏—Å–∫–∞\", \"–∞–π—Ä–∏—Å\" –∏ –¥—Ä.\n- –í—ã—Å–æ–∫–∞—è —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∫ –±—ã—Å—Ç—Ä–æ–π —Ä–µ—á–∏\n- –û—Ñ–ª–∞–π–Ω —Ä–∞–±–æ—Ç–∞ —Å Vosk\n\n## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞\n\n```\nsrc/\n‚îú‚îÄ‚îÄ tts_engine.py         # Edge TTS –¥–ª—è –Ω–µ–∂–Ω–æ–≥–æ –∂–µ–Ω—Å–∫–æ–≥–æ –≥–æ–ª–æ—Å–∞\n‚îú‚îÄ‚îÄ voice_input.py        # Vosk/Google —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏\n‚îú‚îÄ‚îÄ cs2_gsi.py           # CS2 Game State Integration —Å–µ—Ä–≤–µ—Ä\n‚îú‚îÄ‚îÄ streamelements_client.py  # StreamElements WebSocket –∫–ª–∏–µ–Ω—Ç\n‚îú‚îÄ‚îÄ iris_brain.py        # Groq LLM –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤\n‚îú‚îÄ‚îÄ windows_audio.py     # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π\n‚îú‚îÄ‚îÄ achievements.py      # –°–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏\n‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ tts_utils.py     # –£—Ç–∏–ª–∏—Ç—ã —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏\n‚îî‚îÄ‚îÄ __init__.py\n\nmain.py                  # –ì–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª –∑–∞–ø—É—Å–∫–∞\n```\n\n## –ù–∞—Å—Ç—Ä–æ–π–∫–∞\n\n### –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Å–µ–∫—Ä–µ—Ç—ã:\n- `GROQ_API_KEY` - –∫–ª—é—á Groq API (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π, –¥–ª—è AI –æ—Ç–≤–µ—Ç–æ–≤)\n- `STREAMELEMENTS_JWT_TOKEN` - JWT —Ç–æ–∫–µ–Ω StreamElements (–¥–ª—è —á–∞—Ç–∞)\n\n### –ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å Groq API –∫–ª—é—á (–±–µ—Å–ø–ª–∞—Ç–Ω–æ):\n1. –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ https://console.groq.com\n2. –°–æ–∑–¥–∞–π—Ç–µ API –∫–ª—é—á\n3. –î–æ–±–∞–≤—å—Ç–µ –≤ —Å–µ–∫—Ä–µ—Ç—ã Replit\n\n### CS2 Game State Integration:\n1. –ü—Ä–∏ –∑–∞–ø—É—Å–∫–µ —Å–æ–∑–¥–∞—ë—Ç—Å—è —Ñ–∞–π–ª `gamestate_integration_iris.cfg`\n2. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –≤ `<Steam>/steamapps/common/Counter-Strike Global Offensive/game/csgo/cfg/`\n3. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ CS2\n\n## –§—É–Ω–∫—Ü–∏–∏\n\n### üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ\n- –°–∫–∞–∂–∏—Ç–µ \"–ò—Ä–∏—Å\" –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏\n- –ö–æ–º–∞–Ω–¥—ã: \"—Å–¥–µ–ª–∞–π –º—É–∑—ã–∫—É —Ç–∏—à–µ\", \"–≤—ã–∫–ª—é—á–∏ –¥–∏—Å–∫–æ—Ä–¥\", \"–≥—Ä–æ–º–∫–æ—Å—Ç—å –Ω–∞ 50%\"\n- –ü–æ–¥–¥–µ—Ä–∂–∫–∞: \"–ø—Ä–∏–≤–µ—Ç\", \"–∫–∞–∫ –¥–µ–ª–∞\", \"—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\", \"–¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è\"\n\n### üéÆ CS2 –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è\n- –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –ø—Ä–∏ —É–±–∏–π—Å—Ç–≤–∞—Ö, —Å–º–µ—Ä—Ç—è—Ö, clutch —Å–∏—Ç—É–∞—Ü–∏—è—Ö\n- –†–µ–∞–∫—Ü–∏–∏ –Ω–∞ –±–æ–º–±—É, —Ä–∞—É–Ω–¥—ã, MVP\n- –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —é–º–æ—Ä –∏ —ç–º–æ—Ü–∏–∏\n- –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∏–Ω—Ç–æ–Ω–∞—Ü–∏–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∏—Ç—É–∞—Ü–∏–∏\n\n### üí¨ StreamElements\n- –ß—Ç–µ–Ω–∏–µ —á–∞—Ç–∞ –∏ –æ—Ç–≤–µ—Ç—ã –∑—Ä–∏—Ç–µ–ª—è–º\n- –ë–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç–∏ –∑–∞ –¥–æ–Ω–∞—Ç—ã —Å —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º —Å—É–º–º—ã\n- –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–æ–≤—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –∏ —Ä–µ–π–¥–æ–≤\n\n### üèÜ –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è\n- 20+ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è\n- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏—è –≥–æ–ª–æ—Å–æ–º\n- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≤ stream_stats.json\n\n## –ì–æ–ª–æ—Å–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n\n### –î–æ—Å—Ç—É–ø–Ω—ã–µ –≥–æ–ª–æ—Å–∞:\n- `ru_female_soft` - –°–≤–µ—Ç–ª–∞–Ω–∞ (–º—è–≥–∫–∏–π, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)\n- `ru_female_warm` - –î–∞—Ä—å—è (—Ç—ë–ø–ª—ã–π)\n- `ru_male` - –î–º–∏—Ç—Ä–∏–π\n- `en_female_soft` - Jenny (–∞–Ω–≥–ª–∏–π—Å–∫–∏–π)\n- `en_female_warm` - Aria (–∞–Ω–≥–ª–∏–π—Å–∫–∏–π)\n\n### –≠–º–æ—Ü–∏–∏:\n- `neutral` - –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π\n- `excited` - –≤–æ–∑–±—É–∂–¥—ë–Ω–Ω—ã–π\n- `happy` - —Ä–∞–¥–æ—Å—Ç–Ω—ã–π\n- `sad` - –≥—Ä—É—Å—Ç–Ω—ã–π\n- `supportive` - –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–π\n- `gentle` - –Ω–µ–∂–Ω—ã–π\n- `tense` - –Ω–∞–ø—Ä—è–∂—ë–Ω–Ω—ã–π\n\n## –ó–∞–ø—É—Å–∫\n\n```bash\npython main.py\n```\n\n## –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞\n\n### Windows:\n- Python 3.9+\n- –ú–∏–∫—Ä–æ—Ñ–æ–Ω\n- –î–∏–Ω–∞–º–∏–∫–∏/–Ω–∞—É—à–Ω–∏–∫–∏\n- CS2 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)\n\n### –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:\n```bash\npip install edge-tts pygame vosk groq flask websockets python-dotenv sounddevice SpeechRecognition\n```\n\n### –î–ª—è Vosk (–æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ):\n```bash\n# –°–∫–∞—á–∞–π—Ç–µ —Ä—É—Å—Å–∫—É—é –º–æ–¥–µ–ª—å\nwget https://alphacephei.com/vosk/models/vosk-model-small-ru-0.22.zip\nunzip vosk-model-small-ru-0.22.zip -d models/\n```\n\n## –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏\n\n- Python 3.11\n- Edge TTS (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏ Microsoft)\n- Vosk (–æ—Ñ–ª–∞–π–Ω —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏)\n- Groq LLM (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π AI)\n- Flask (HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è CS2 GSI)\n- WebSocket (StreamElements)\n- pygame (–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ)\n\n## –ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n- –¢–æ–ª—å–∫–æ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã\n- –ù–µ–∂–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å\n- –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ wake-word\n- –ö—Ä–æ—Å—Å–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–æ—Å—Ç—å (Windows, Linux, macOS)\n","path":null,"size_bytes":6318,"size_tokens":null}},"version":2}